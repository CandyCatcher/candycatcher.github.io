# Java 基础

## 面向对象和面向过程的区别

1. <u>面向过程是一种以事物为中心的编程思想。主要关注“怎么做”。即编程的时候把解决问题的步骤分析出来，然后用代码把这些步骤一步一步的实现。</u>
   * 优点：<u>流程化使得编程任务明确，在开发之前基本考虑了实现方式和最终结果，具体步骤清楚，便于节点分析。效率</u>高，面向过程强调代码的短小精悍，善于结合数据结构来开发高效率的程序。
   * 缺点：需要深入的思考，耗费精力，<u>代码重用性低，扩展能力差，后期维护难度比较大</u>。
2. <u>面向对象是一种以对象为基础的编程思想。主要关注“谁来做”，即完成任务的对象。把要解决的问题分解成各个对象，描述某个对象在整个解决问题的步骤中的属性和行为，在代码中通过调用对象来完成任务。</u>
   * 优点: 结构清晰，程序是模块化和结构化，更加符合人类的思维方式；<u>易扩展，代码重用率高，可继承，可覆盖，可以设计出低耦合的系统；易维护</u>，系统低耦合的特点有利于减少程序的后期维护工作量。
   * 缺点：开销大，当要修改对象内部时，对象的属性不允许外部直接存取，所以要增加许多没有其他意义、只负责读或写的行为。这会为编程工作增加负担，增加运行开销，并且使程序显得臃肿。<u>性能低，由于面向更高的逻辑抽象层，使得面向对象在实现的时候，不得不做出性能上面的牺牲，计算时间和空间存储大小都开销很大。</u>

## 字符型常量和字符串常量的区别?

- 形式上字符常量是单引号引起的一个字符，字符串常量是双引号引起的若干个字符
- 含义上字符常量相当于一个整型值（ASCII值）可以参加表达式运算，字符串常量代表一个地址值（该字符串在内存中存放位置）
- 字符常量只占2个字节，字符串常量占若干个字节

## 构造器 Constructor 是否可被 override?

Constructor不能被override (重写)，但是可以overload (重载)，所以可以看到一个类中有多个构造函数的情况。

## 重载和重写的区别

<u>重载：重载发生在同一个类中，重载的方法之间方法名必须相同，参数列表必须不同，方法返回类型、访问修饰、异常可以不同。</u>总之，重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。

重写：重写发生在子类和父类之间。重写的方法之间参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等，子类方法的访问权限应比父类方法的访问权限更大或相等。

## Java 面向对象编程三大特性

* **封装** 封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。

* **继承** 继承是使用已存在的类的定义作为基础建立一个新类，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。

* **多态** 所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编译时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。

  在Java中有两种形式可以实现多态:继承(多个子类对同一方法的重写)和接口(实现接口并 覆盖接口中同一方法)。

## String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?

1. String类中使用final关键字修饰字符数组来保存字符串， private final char value[] ，所以String对象是不可变的。在jdk9之后，String类的实现改用Byte数组存储字符串。
2. 而StringBuffer与StringBuilder都继承自AbstractStringBuilder类，在AbstractStringBuilder类中也是使用字符数组保存字符串char[ ] value， 但是没有用final关键字修饰，所以这两种对象都是可变的。
3. 每次对String类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String对象。StringBuilder对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。 StringBuffer并没有对方法进行加同步锁，所以是非线程安全的。

## 自动装箱与拆箱 

装箱：将基本类型用它们对应的引用类型包装起来;

拆箱：将包装类型转换为基本数据类型; 在装箱的时候自动调用的是Integer的valueOf(int)方法。

在拆箱的时候自动调用的是Integer的intValue方法。longValue charValue booleanValue

## 接口和抽象类的区别是什么?

- 从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。
- 一个类可以实现多个接口，但只能实现一个抽象类。并且接口自己本身可以通过 extends 关键字扩展多个接口。
- 接口中除了 static 、 final 变量，不能有其他变量，而抽象类中则不一定。
- 接口方法默认修饰符是 public ，抽象方法可以有 public 、 protected 和 default 这些修饰符(抽象方法就是为了被重写所以不能使用 private 关键字修饰!)。

## 成员变量与局部变量的区别有哪些?

- 从语法形式上看成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数; 成员变量可以被 public  private  static 等修饰符所修饰，而局部变量不能被访问控制修饰 符及 static 所修饰;但是，**成员变量和局部变量都能被 final 所修饰。**
- 从变量在内存中的存储方式来看。如果成员变量是使用 static 修饰的，那么这个成员变量是属于类的，如果没有使用 static 修饰，这个成员变量是属于实例的。对象存于堆内存，如果局部变量类型为基本数据类型，那么存储在栈内存，如果为引用数据类型，那存放的是指向堆内存对象的引用或者是指向常量池中的地址。
- 从变量在内存中的生存时间上看。成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。
- <u>成员变量如果没有被赋初值则会自动以类型的默认值而赋值(一种情况例外被 final 修饰的成员变量也必须显式地赋值)，而局部变量则不会自动赋值。</u>

## final 

final变量未初始化时系统不会进行隐式初始化。编译就会报错 final修饰的基本类型变量不能被修改。 final只保证这个引用类型变量所引用的地址不会发生改变。

1. 类变量：必须要在静态初始化块中指定初始值或者声明该类变量时指定初始值，而且只能在这两个地方之一进行指定;
2. 实例变量：必须要在非静态初始化块、声明该实例变量或者在构造器中指定初始值，而且只能在这三个地方进行指定。

当一个方法被final关键字修饰时，说明此方法不能被子类重写。 当一个类被final修饰时，表示该类是不能被子类继承的。

对于final域，编译器和处理器要遵守两个重排序规则。

1. 在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。(所以还是会出现线程安全的问题。当这个对象构造完成后，别的线程对引用变量修改与之后读取是可以重排序的)

2. 初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。

   (也就是初次读引用变量obj和初次读引用变量obj指向对象的final域i这两个操作不能重排序的)

为什么String是final修饰的?

1. final修饰的String，代表了String的不可继承性，
2. final以及private修饰的char[]代表了被存储的数据不可更改性。

(我们知道引用类型的不可变仅仅是引用地址不可变，不代表了数组本身不会变，这个时候，起作用的还有private，正是因为两者保证了String的不可变性)

## 字符串池的实现，为什么有字符串池？

1. 为了实现字符串池。字符串池的实现可以在运行时节约很多heap空间，因为不同的字符串变量都指向池中的同一个字符串。但如果字符串是可变的，那么字符串池将不能实现，因为这样的话，如果变量改变了它的值，那么其它指向这个值的变量的值也会一起改变。比如说我在一 个“aaa”的字符串后面加了一段“bb”，那么这个原来的“aaa”不存在了，这是不允许的，尤 其是在HashSet或者HashMap中。
2. 为了实现多线程的安全性，同一个字符串实例可以被多个线程共享。这样便不用因为线程安全问题而使用同步。字符串自己便是线程安全的。
3. 为了实现HashCode就被缓存了，不需要重新计算。这就使得字符串很适合作为Map中的键，字符串的处理速度要快过其它的键对象。这就是HashMap中的键往往都使用字符串。

## == 与 equals

* == 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象基本数据类型比较的是值，引用数据类型比较的是内存地址。
* `equals()` 它的作用也是判断两个对象是否相等。但它一般有两种使用情况:
  * 情况1 :类没有覆盖`equals()` 方法。则通过`equals()` 比较该类的两个对象时，等价于通过==比较这两个对象。
  * 情况2 :类覆盖了`equals()` 方法。一般，我们都覆盖`equals()`方法来比较两个对象的内容是否相等;若它们的内容相等，则返回 true。

> String 中的`equals()` 方法是被重写过的，因为Object的`equals()` 方法比较的是对象的内存地址，而String的`equals()` 方法比较的是对象的值。
> 当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。

## 你重写过 hashcode 和 equals 么，为什么重写 equals 时必须重写hashCode 方法?

`hashCode()`的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。 `hashCode()`定义在 Object 类中，这就意味着 Java 中的任何类都包含有 `hashCode()` 函数。

**为什么要有hashcode？**

当你把对象加入 HashSet 时， HashSet 会先计算对象的 hashcode 值来判断对象加入的位置， 同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的 ， HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 `equals() `方法来检查 hashcode 相等的对象是否真的相同。如果两者相同， HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 `equals() ` 的次数，相应就大大提高了执行速度。

**为什么重写 equals 时必须重写 hashCode 方法?**

如果两个对象调用`equals() `方法返回true，那么这两个对象的hashcode也一定是相同的。如果没有重写 hashCode() ，则该 的两个对象无论如何都不会相等(即使这两个对象指向相同的数据)。

## 为什么 Java 中只有值传递?

Java程序设计语言对对象采用的不是引用调用，实际上，对象引用是按值传递的。

下面再总结一下 Java 中方法参数的使用情况:

* 一个方法不能修改一个基本数据类型的参数(即数值型或布尔型)。
* 一个方法可以改变一个对象参数的状态。
* 一个方法不能让对象参数引用一个新的对象。

# 集合

## 说说List,Set,Map三者的区别?

1. List 存储的元素是有序的、可重复的。
2. Set 存储的元素是无序的、不可重复的。
3. Map 使用键值对存储。key是无序的、不可重复的， value是无序的、可重复的，每个键最多映射到一个值。

## Arraylist 与 LinkedList 区别?

- 是否保证线程安全: ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全;

- 底层数据结构: Arraylist 底层使用的是 Object 数组; LinkedList 底层使用的是 双向链表 ；

- 插入和删除是否受元素位置的影响: ArrayList 采用数组存储，所以插入指定位置和删除元素的时间复杂度受元素位置的影响。LinkedList 采用链表存储，插入指定位置的时间复杂度受元素位置的影响。

  ArrayList执行 `add(E e)` 方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是O1。但是如果要在指定位置插入和删除元素的话`add(int index, E element) `时间复杂度就为O(n-i)。因为在进行上述操作的时候集合中第i和第i个元素之后的n-i个元素都要执行向后/向前移一位的操作。

  LinkedList对于 add(E e) 方法的插入，删除元素时间复杂度不受元素位置的影响，近似 O(1)，如果是要在指定位置 i 插入和删除元素的话`(add(int index, E element) `时间复杂度近似为 o(n)，因为需要先移动到指定位置再插入。

- 是否支持快速随机访问: LinkedList 不支持高效的随机元素访问，而 ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素对象对应于 get(int index) 方法。

- 内存空间占用:  Arraylist的空间浪费主要体现在在 Arraylist 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 Arraylist 更多的空间 (因为要存放直接后继和直接前驱以及数据)。

## ArrayList的扩容机制:

在新增之前他会有一步校验长度的判断`ensureCapacityInternal`，就是说如果长度不够，是需要扩容的: `newCapacity = oldCapacity + (oldCapacity >> 1) `，实际上就是n+n/2。再把原来数组的值复制到新数组里面。

## ArrayList(int initialCapacity)会不会初始化数组大小?

不会初始化数组大小!而且将构造函数与initialCapacity结合使 用，然后使用set()会抛出异常，尽管该数组已创建，但是大小设置不正确。

## ArrayList插入删除一定慢么?

取决于你删除的元素离数组末端有多远，ArrayList拿来作为堆栈来用还是挺合适的，push和pop操作完全不涉及数据移动操作。

## ArrayList的删除怎么实现的呢?

删除其实跟新增是一样的，不过叫是叫删除，但是在代码里面我们发现，他还是在copy一个数组。

比如我们现在要删除下面这个数组中的index=5这个位置，会复制一个index=5+1开始到最后的数组，然后把它放到index 开始的位置index5的位置就成功被”删除“了其实就是被覆盖了，给了你被删除的感觉。同理他的效率也低，因为数组如果很大的话，一样需要复制和移动的位置就大了。

## ArrayList 与 Vector 区别呢?为什么要用Arraylist取代 Vector呢?

* ArrayList 是 List 的主要实现类，底层使用 Object[ ] 存储，适用于频繁的查找工作，线 程不安全 ;
* Vector 是 List 的古老实现类，底层使用 Object[ ] 存储，线程安全的。

## 同步容器(如Vector)的所有操作一定是线程安全的吗?

Vector这样的同步容器的所有公有方法全都是synchronized的，也就是说，我们可以在多线程场景中放心的使用单独 这些方法，因为这些方法本身的确是线程安全的。 比如说线程2通过index()获得索引值为10，在尝试通过remove()删除该索引位置的元素之前，线程1把该索引位置的值 删除掉了，这时线程一在执行时便会抛出异常。 所以同步容器只能保证单个操作的线程安全性，但是无法保证复合操作的线程安全，遇到这种情况时，必须要通过 主动加锁的方式来实现。 而且，除此之外，同步容易由于对其所有方法都加了锁，这就导致多个线程访问同一个容器的时候，只能进行顺序 访问，即使是不同的操作，也要排队，如get和add要排队执行。这就大大的降低了容器的并发能力。

## HashMap 和 Hashtable 的区别

-  线程是否安全: HashMap 是非线程安全的， HashTable 是线程安全的。因为 HashTable 内 部的方法基本都经过 synchronized 修饰。

- 效率: 因为线程安全的问题， HashMap 要比 HashTable 效率高一点。另外， HashTable基本被淘汰，不要在代码中使用它;

- 对 Null key 和 Null value 的支持: HashMap 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个; 不允许有 null 键和 null 值，否则会抛出 NullPointerException 。

  **二义性+多线程:** 假设这时有A、B两个线程。线程A调用`concurrentHashMap.get(key)`方法,返回为null，我们还是不知道这个 null是没有映射的null还是存的值就是null。我们假设此时返回为null的真实情况就是因为这个key没有在map 里面映射过。那么我们可以用`concurrentHashMap.containsKey(key)`来验证我们的假设是否成立，我们期望的结果是返回false。但是在我们调用`concurrentHashMap.get(key)`方法之后，containsKey方法之前，有一个线程 B执行了`concurrentHashMap.put(key,null)`的操作。那么我们调用containsKey方法返回的就是true了。这就与我们的假设的真实情况不符合了。对于HashMap的正确使用场景是在单线程下使用，所以ConcurrentHashMap不能存空的键值对。

- 初始容量大小和每次扩充容量大小的不同 : 

  1. 创建时如果不指定容量初始值， Hashtable 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。 HashMap 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。
  2. 创建时如果给定了容量初始值，那么 hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为 2 的幂次方大小。也就是说 HashMap 总是使用 2 的幂作为哈希表的大小.

-  底层数据结构:  HashMap当链表⻓度大于阈值(默认为8 )，将链表转换成红黑树前会判断，如果当前数组的⻓度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树；如果大于64则将链表转化为红黑树，以减少搜索时间。 

## HashMap 和 HashSet区别

HashSet 底层就是基于 HashMap 实现的。( HashSet 的源码非常非常少，因为除了 clone() 、 writeObject() 、 readObject() 是 HashSet 自己不得不实现之外，其他方法都是直接调用 HashMap 中的方法。

## HashSet如何检查重复？

当你把对象加入 HashSet 时， HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同 时也会与其他加入的对象的 hashcode 值作比较，如果没有相符的 hashcode ， HashSet 会假设 对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals() 方法来检查hashcode 相等的对象是否真的相同。如果两者相同， HashSet 就不会让加入操作成功。

## HashMap的PUT实现

根据key的hashcode 经过高低位异或之后的值，与数组长度-1进行与运算得到元素应该存放的位置，(都是2的次幂所以等同于取模，但是位运算的效率更高)。找到数组中的位置之后，如果该位置没有元素就直接存入，反之则判断这个位置node节点key的值和hashcode是否相同（key相同就通过equals() 方法来检查hashcode 相等的对象是否真的相同），如果相同就覆盖value。然后如果该位置已经是链表了，那么就将key，value包装成节点node，插入到链表的尾部。插入成功后，如果链表的长度超过8，接着判断数组长度是否超过64，如果没有达到64就会进行扩容，如果达到64，就将链表转为红黑树。如果已经是红黑树了，那就将节点加入到红黑树中。最后，如果键值对的个数已经超过了一个阈值，也就是数组长度乘负载因子得到的值，那就进行扩容。

## HashMap的GET实现

如果数组不为null，数组长度大于0，根据hash计算出来的槽位的元素不为null。如果通过key的hash值和equals方法判断key相同，即查找的元素在数组中，返回该元素。如果第一个元素不同，并且链表或者红黑树的size不为0的话，则在链表或红黑树中遍历找到对应的key。

## HashMap 的⻓度为什么是2的幂次方

1. 取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&)操作(也就是说 `hash%length==hash&(length-1)`的前提是 length 是2的 n 次方)。 采用二进制位操作 &，相对于%能够提高运算效率。

2. 另外，我们使用的是2的n次幂进行扩展(指长度扩为原来2倍)，resize的时候，元素的位置要么是在原位置，要么是在原位置再移动2的n次幂的位置。能加快移动的效率。

   看下图可以明白这句话的意思，n为table的长度，图(a)表示扩容前的key1和key2两种key确定索引位置的示例，图(b)表示扩容后key1和 key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。

   ![image-20240714112633314](https://cdn.jsdelivr.net/gh/candyboyou/imgs/imgimage-20240714112633314.png)

## 新的Entry节点在插入链表的时候，是怎么插入的么?

java8之前是头插法，就是说新来的值会取代原有的值，原有的值就顺推到链表中去，因为写这个代码的作者认为后来的值被查找的可能性更大一点，提升查找的效率。但是，在java8之后，都是用尾部插入了。 

这是因为会出现死循环的问题。比如说在容量为2的容器里面用不同线程插入A(线程1)，B，C(线程2)，原来的链表可能是A->B->C，但是经过resize之后，C去了别的位置，只对B进行操作，B 的下一个指针可能指向了A。使用头插会改变链表上的顺序，但是如果使用尾插，在扩容时会保持链表元素原本的顺序，就不会出现链表成环的问题了。 但是即使不会出现死循环，通过源码能看到put/get方法都没有加同步锁，多线程情况最容易出现的就是:无法保证上一秒put的值，下一秒get的时候还是原值(数据覆盖)，所以线程安全还是无法保证。

## 重写equals方法的时候需要重写hashCode方法呢? 

在未重写equals方法我们是继承了object的equals方法，那里的 equals是比较两个对象的内存地址， 对于值对象，==比较的是两个对象的值;对于引用对象，比较的是两个对象的地址。HashMap是 通过key的hashCode去寻找index的，不同对象的hashcode有几率相同的，此时就需要通过equals方法 进行判断了。所以如果我们对equals方法进行了重写，建议一定要对hashCode方法重写，以保证相 同的对象返回相同的hash值，不同的对象返回不同的hash值。

## HashMap 多线程操作导致死循环问题

主要原因在于 并发下的 会造成元素之间会形成一个循环链表。不过，  后解决了这 个问题，但是还是不建议在多线程下使用 因为多线程下使用  还是会存在其 他问题比如数据丢失。并发环境下推荐使用  。

## 既然HashMap并不会直接接收用户传入的初始容量，那么为什么《阿里巴巴Java开发手册》还是建议开发者在创建HashMap的时候制定一个初始容量呢?这个容量设置成多少合适呢?

如果我们没有设置初始容量大小，随着元素的不断增加，HashMap会发生多次扩容，而HashMap中的 扩容机制决定了每次扩容都需要重建hash表，是非常影响性能的。

## HashMap是如何找到比传入的指定值大的第一个2的幂的?

要求获得的是大于cap的最小的2的幂。常规算法累加后判定，巨慢。而考虑二进制的话，2的幂一定 一个1后面跟一堆0的情况。那么问题就化简了，例如给出一个10，其二进制为1010，那就将10的所有位都变为1，然后再加1

## jdk8 HashMap为什么要引入红黑树呢？

其实主要就是解决hash冲突导致链化严重的问题，如果链表过长，查找时间复杂度为O(n)，效率变慢。本身散列表最理想的查询效率为O(1)，但是链化特别严重，就会导致查询退化为O(n)。严重影响查询性能了，为了解决这个问题，JDK1.8它才引入的红黑树。红黑树其实就是一颗特殊的二叉排序树，这个时间复杂度是log(N)

## 问：那为什么链化之后性能就变低了呀？

因为链表它毕竟不是数组，它从内存角度来看，它没有连续着。如果我们要往后查询的话，要查询的数据它在链表末尾，那只能从链表一个节点一个节点Next跳跃过去，非常耗费性能。

## 问：再聊聊hashmap的扩容机制吧？你说一下，什么情况下会触发这个扩容呢？

在写数据之后会触发扩容，可能会触发扩容。hashmap结构内，我记得有个记录当前数据量的字段，这个数据量字段达到扩容阈值的话，下一个写入的对象是在列表才会触发扩容

## 问：扩容后会扩容多大呢？这块算法是咋样的呢？

因为table 数组长度必须是2的次方数嘛，扩容其实，每次都是按照上一次的tableSize位移运算得到的。就是做一次左移1位运算，假设当前tableSize是16的话，16 << 1 == 32

## 问：这里为什么要采用位移运算呢？咋不直接tableSize乘以2呢？

主要是因为性能，因为cpu毕竟它不支持乘法运算，所有乘法运算它最终都是在指令层面转化为加法实现的。效率很低，如果用位运算的话对cpu来说就非常简洁高效

## 问：hashCode值为什么需要高16位 ^ 低16位

主要为了优化hash算法，近可能的分散得比较均匀，尽可能的减少碰撞。因为hashmap内部散列表，它大多数场景下，它不会特别大。hashmap内部散列表的长度，也就是说 length - 1 对应的 二进制数，实际有效位很有限，一般都在（低）16位以内，这样的话，key的hash值高16位就等于完全浪费了，没起到作用。所以，node的hash字段才采用了 高16位 异或 低16位 这种方式来增加随机的概率，近可能的分散得比较均匀，尽可能的减少碰撞。

注意：2的16次方为 64K

## 问：默认的负载因子是多少？ 并且这个负载因子有啥用？

默认负载因子0.75，就是75%，负载因子它的作用就是计算扩容阈值用的，比如使用无参构造方法创建的hashmap对象，它默认情况下扩容阈值就 16*0.75 = 12

## 问：链表它转化为这个红黑树需在达到什么条件？

链表转红黑树，主要是有两个指标，其中一个就是链表长度达到8，还有一个指标就是当前散列表数组长度它已经达到64。如果当前散列表数组长度它没有达到64，就算slot内部链表长度到了8，它也不会链转树，它仅仅会发生一次resize，散列表扩容。

## HashMap中存储数据的结构，长什么样啊？

JDK1.7 是 数组 + 链表；

JDK1.8是 数组 + 链表 + 红黑树，每个数据单元都是一个Node结构，Node结构中有key字段、有value字段、还有next字段、还有hash字段。

Node结构next字段就是发生hash冲突的时候，当前桶位中node与冲突的node连成一个链表要用的字段。

## HashMap为什么从链表换成了树？ 为啥不用AVL树？

平衡二叉树也叫AVL（发明者名字简写），也属于二叉搜索树的一种，与其不同的是AVL通过机制保证其自身的平衡。

平衡二叉树的原则有以下几点：

* 对于根结点而言，它的左子树任何节点的key一定比其小而右子树任何节点的key一定比其大；
* 对于AVL树而言，其中任何子树仍然是AVL树；
* 每个节点的左右子节点的高度之差的绝对值最多为1；

由于AVL树必须保证Max(最大树高-最小树高) <= 1所以在插入的时候很容易出现不平衡的情况，一旦这样，就需要进行旋转以求达到平衡。正是由于这种严格的平衡条件，导致需要花大量时间在调整上，故AVL树一般使用场景在于查询而弱于增加删除。

红黑树继承了AVL可自平衡的优点，同时在查询速率和调整耗时中寻找平衡，放宽了树的平衡条件，在实际应用中，红黑树的使用要多得多。

## 红黑树

### 红黑树的性质（规则）

红黑树是一种含有红黑结点并能自平衡的二叉查找树。它必须满足下面性质：

1. 性质1：每个节点要么是黑色，要么是红色。
2. 性质2：根节点是黑色。
3. 性质3：每个叶子节点（NIL）是黑色。
4. 性质4：每个红色结点的两个子结点一定都是黑色。
5. 性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。（保证这棵树尽量是平衡的。）

## 一般在多线程的场景，有这么几种不同的方式去代替:

1. 使用Collections.synchronizedMap(Map)创建线程安全的map集合;
2. Hashtable
3. ConcurrentHashMap

## Collections.synchronizedMap是怎么实现线程安全的你有了解过么? 

在SynchronizedMap内部维护了一个普通对象Map，还有排斥锁mutex。我们在调用这个方法的时候就 需要传入一个Map，可以看到有两个构造器，如果你传入了mutex参数，则将对象排斥锁赋值为传入 的对象。如果没有，则将对象排斥锁赋值为this，即调用synchronizedMap的对象，就是上面的Map。 创建出synchronizedMap之后，再操作map的时候，就会对方法上锁。

## put操作

当添加一对键值对的时候，首先会去判断保存这些键值对的数组是不是初始化了，如果没有的话就初始 化数组。然后通过计算hash值来确定放在数组的哪个位置，如果这个位置为空则直接添加。如果不为空的 话，则拿到这个位置的头节点，头节点的hash值是MOVED(-1)的话，则表示当前正在对这个数组进行扩 容，复制到新的数组，则当前线程也去帮助复制。如果这个节点，不为空，也不在扩容，则通过 synchronized来加锁，进行添加操作。然后判断当前取出的节点位置存放的是链表还是树，如果是链表的 话，则遍历整个链表，直到取出来的节点的key来个要放的key进行比较，如果key相等，并且key的hash值 也相等的话，则说明是同一个key，则覆盖掉value，否则的话则添加到链表的末尾。如果是树的话，则调 用putTreeVal方法把这个元素添加到树中去。最后在添加完成之后，会判断在该节点处共有多少个节点 (注意是添加前的个数)，如果达到8个以上了的话，则调用treeifyBin方法来尝试将处的链表转为树，或 者扩容数组

## get操作

1. 使用扰动函数计算key的hash值，取到其所在的数组下标位置。
2. 如果节点是首节点，直接返回。
3. 如果节点的hash值eh是负值，说明ConCurrentHashMap正在进行扩容，或该节点是一个树节点TreeBin。
4. 如果eh=-1表示正在扩容，该节点是一个 ForwardingNode（树头节点），直接调用ForwardingNode的find方法去nextTable里找；
5. 如果eh=-2，该节点是一个TreeBin，调用TreeBin的find()方法遍历红黑树，由于红黑树有可能在变色旋转，所以find()里会有读写锁。

## concurrentHashMapz怎么统计size?

JDK1.8 size 是通过对 baseCount 和 counterCell 进行 CAS 计算，最终通过 baseCount 和 遍历 CounterCell 数组得出 size。

JDK 8 推荐使用mappingCount 方法，因为这个方法的返回值是 long 类型，不会因s为 size 方法是 int 类 型限制最大值。

1. 先通过CAS尝试更新baseCount ，如果更新成功则完成，如果CAS更新失败会进入下一步使用CAS操作修改counterCells中的值
2. 首先线程通过随机数ThreadLocalRandom.getProbe() & (n-1) 计算出在counterCells数组的位置，如果不为 null，则CAS尝试在couterCell上直接增加数量
3. 如果counterCells为空，或者修改counterCells的CAS操作失败，则执行fullAddCount方法
4. 在fullAddCount方法中一直循环，一直通过cas修改cellsBusy的值或者一直修改baseCount的值，如果两个操作有一个成功就退出



