## 介绍下 Java 内存区域(运行时数据区)

虚拟机在执行程序的过程中会把它管理的内存划分成若干个不同的数据区域。

<img src="https://cdn.jsdelivr.net/gh/candyboyou/imgs/imgimage-20240712185933882.png" alt="image-20240712185933882" style="zoom:33%;" />

<img src="https://cdn.jsdelivr.net/gh/candyboyou/imgs/imgimage-20240712190009922.png" alt="image-20240712190009922" style="zoom:33%;" />

1. 程序计数器

   1. 程序计数器是线程私有的。
   2. 程序计数器是当前线程所执行的字节码的行号指示器。
   3. 字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳 转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。
   4. 程序计数器是唯一一个不会出现 **OutOfMemoryError** 的内存区域，它的生命周期随着线 程的创建而创建，随着线程的结束而死亡。

   > 程序计数器主要有两个作用:
   >
   > 1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如:顺序执 行、选择、循环、异常处理。
   > 2.  在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。

2. Java 虚拟机栈

   1. Java 虚拟机栈也是线程私有的。
   2. Java 虚拟机栈描述的是 Java方法执行的内存模型，每次方法调用的数据都是通过栈传递的。
   3. 虚拟机栈是由一个个栈帧组成，而每个 栈帧中都拥有:局部变量表、操作数栈、动态链接、方法出口信息。
   4. Java 虚拟机栈会出现两种错误: **StackOverFlowError** 和 **OutOfMemoryError** 。

   > **StackOverFlowError** : 若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈 的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError错误。
   >
   > **OutOfMemoryError** : 若Java虚拟机堆中没有空闲内存，并且垃圾回收器也无法提供更多内存的话。就会抛出OutOfMemoryError错误。

3. 本地方法栈

   1. 和虚拟机栈所发挥的作用非常相似，区别是本地方法栈为虚拟机使用到的 Native 方法服务。 在HotSpot虚拟机中和Java虚拟机栈合二为一。

4. 堆

   1. 堆是所有线程共享的一块内存区域

   2. 此内存区域的唯一目的就是存放对象实例，**几乎**所有的对象实例以及数组都在这里分 配内存。

   3. 从jdk 1.7开始已经默认开启逃逸分析，<u>如果某些方法中的对象引用没有被返回或者未被外面使用</u>(也就是未逃逸出去)，那么对象可以直接在栈上分配内存。

   4.  堆是垃圾收集器管理的主要区域，因此也被称作GC 堆(Garbage Collected Heap)。从垃 圾回收的⻆度，由于现在收集器基本都采用分代垃圾收集算法，所以堆还可以细分为：新生代和老年代；再细致一点有:Eden 空间、From Survivor空间、To Survivor空间等。进一步划分的目的是更好地回收内存，或者更快地分配内存。

   5. 堆这里最容易出现的就是**OutOfMemoryError**错误，并且出现这种错误之后的表现形式还会有几 种，比如:

       **OutOfMemoryError: GC Overhead Limit Exceeded** : 当花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。

       **OutOfMemoryError: Java heap space** 假如在创建新的对象时堆内存中的空间不足以存放新创建的对象 就会引发 java.lang.OutOfMemoryError: Java heap space 错误。和本机物理内存无关，和你配置的内存大小有关!

5. 方法区

   1. 方法区与堆一样，是各个线程共享的内存区域
   2. 它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
   3. Java虚拟机永久代实现了方法区
   4. jdk1.8版本之后方法区( HotSpot的永久代)被彻底移除了，取而代之的是元空间，元空间使用的是直接内存。

   为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?

   整个永久代有一个JVM本身设置固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。

   5. 元空间的大小确实是内存剩余的大小。堆内存的大小是会变的 JVM初始是128M，最大是大约2G。这是因为存在一个内存延迟分配的机制。
   6. 元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 MaxPermSize 控制了，而由系统的实际可用空间来控制，这样能加载的类就更多了。

6. 运行时常量池

   1. 运行时常量池是方法区的一部分。 
   2. 用于存放编译期生成的各种字面量和符号引用
   3. 会抛出OutOfMemoryError错误。

   > 1. JDK1.7之前运行时常量池逻辑包含字符串常量池存放在方法区，此时hotspot虚拟机对方法区的实现为永久代
   > 2. JDK1.7字符串常量池被从方法区拿到了堆中，这里没有提到运行时常量池，也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东⻄还在方法区, 也就是hotspot中的永久代
   > 3. JDK1.8 hotspot移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间 (Metaspace)

   相关问题: 常量池中存储的是对象还是引用呢?

   JDK1.8版本的字符串常量池中存的是字符串对象，以及字符串常量值。

7. 直接内存

   直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部 分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。本机直接内存的分配不会受到  堆的限制，但是，既然是内存就会受到本机总内存大小以及 处理器寻址空间的限制。

## 说一下Java对象的创建过程

1. 类加载检查

   1. 虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用
   2. 检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有先执行相应的类加载过程。

2. 分配内存

   在类加载检查通过后，接下来虚拟机将为新生对象分配内存。分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。

   > **内存分配的两种方式?**
   >
   > 选择以上两种方式中的哪一种，取决于堆内存是否规整。而堆内存是否规整，取决于GC收集器的算法是标记清除，还是标记整理(也称作标记压缩)，值得注意的是，复制算法内存也是规整的。
   >
   > ![image-20240712200812939](https://cdn.jsdelivr.net/gh/candyboyou/imgs/imgimage-20240712200812939.png)
   >
   > **JVM怎么知道要分配的对象的大小?**
   >
   > 对象由 对象头 + 实例数据 + padding填充字节组成，虚拟机规范要求对象所占内存必须是8的倍数，padding 就是干这个的。其中Java中对象头由 Markword + 类指针kclass(该指针指向该类型在方法区的元类型) 组成。
   >
   > 当请求分配的内存大于refill_waste的时候，会选择在堆内存中分配。若小于refill_waste值，则会废弃当前TLAB，重新创建TLAB进 行对象内存分配。 
   >
   > **分配内存的线程安全**
   >
   > 在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全:
   >
   > * CAS+失败重试:  是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试直到成功。虚拟机采用CAS配上失败重试的方式保证更新操作的原子性。
   >
   > * TLAB: 为每一个线程预先在Eden区分配一块儿内存，JVM在给线程中的对象分配内存时，首先在TLAB分配，当对象大于TLAB中的剩余内存或YLAB的内存已用尽时，再采用上述的CAS进行内存分配。
   >
   >   TLAB全称是 Thread Local Allocation Buffer，即线程本地分配缓存，是一个线程专用的内存分配区域。

3. 初始化零值。

   **内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值。**

4. 设置对象头。

   **初始化零值完成之后，虚拟机要对对象进行必要的设置，**例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

5. 执行 init 方法

   在上面工作都完成之后，从虚拟机的视⻆来看，一个新的对象已经产生了，但从  程序的视 ⻆来看，对象创建才刚开始， <init> 方法还没有执行，所有的字段都还为零。所以一般来说， **执行new指令之后会接着执行 <init> 方法，把对象按照程序员的意愿进行初始化，这样一个真 正可用的对象才算完全产生出来。**

## 对象的访问定位有哪两种方式?

建立对象就是为了使用对象，我们的程序通过栈上的reference数据来操作堆上的具体对象。

1. 使用句柄。从堆中划分出一块内存来作为**句柄池**，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据(指向堆中的实例池中)与类型数据(指向方法区中对象类型数据)各自的具体地址信息。
2. 使用直接指针。直接指针直接访问堆中的实例池，然后类型数据指向方法区。
3. 使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄 地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。

## 堆内存中对象的分配的基本策略

1. 对象优先在 eden 区分配。大多数情况下，对象在新生代中 eden 区分配。当 eden 区没有足够空间进行分配时，虚拟机将发起一次Minor GC。 而Minor GC将Eden区的对象存入到survior区中。这里有一种特殊情况，如果有对象无法存入survior区域中，就会启用分配担保， 将该对象提前转移到老年代中，然后再将新对象存入Eden区。

   > 什么是分配担保?
   >
   > 在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，
   >
   > 如果大于，则此次Minor GC是安全的(因为eden的放不进survior中就会放到old中) 如果小于，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果 HandlePromotionFailure=true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象 的平均大小，如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的;如果小于或者 HandlePromotionFailure=false，则改为进行一次Full GC

2. 大对象直接进入老年代。大对象就是需要大量连续内存空间的对象(比如:字符串、数组)。

3. 如果对象在 eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话， 将被移动到 Survivor 空间中，并将对象年龄设为1. 对象在 Survivor 中每熬过一次  Minor GC ， 年龄就增加 1 岁，当它的年龄增加到一定程度(默认为 15 岁)，同时还会结合动态对象年龄进行判定，将对象晋升到老年代中。

   > HotSpot遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的一半时，取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值。

##  如何判断对象是否死亡?

1. 引用计数法

   给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的。

2. 可达性分析法

   这个算法的基本思想就是通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。

可作为 GC Roots 的对象包括下面几种:

- 虚拟机栈(栈帧中的本地变量表)中引用的对象 - 本地方法栈(Native 方法)中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 所有被同步锁持有的对象

## 对象可回收，就一定会被回收吗?

并不是，对象的 finalize 方法给了对象一次垂死挣扎的机会，当对象不可达(可 回收)时，当发生GC时，会先判断对象是否执行了 finalize 方法，如果未执行，则会先执行 finalize 方法，我们可以在 此方法里将当前对象与 GC Roots 关联，这样<u>执行 finalize 方法之后，GC 会再次判断对象是否可达，如果不可达，则会被回收，如果可达，则不回收!</u>

**注意: finalize 方法只会被执行一次，如果第一次执行 finalize 方法此对象变成了可达确实不会回收，但如果对象再次被 GC，则会忽略 finalize 方法，对象会被回收!这一点切记!**

## 简单的介绍一下强引用、软引用、弱引用、虚引用

* **强引用** 我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用
* **软引用** 如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存
* **弱引用** 在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存
* **虚引用** 在任何时候都可能被垃圾回收。虚引用主要用来跟踪对象被垃圾回收的活动。虚引用必须和引用队列()联合使 用。当垃 圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前， 把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是 否已经加入了虚引 用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队 列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。

## 如何判断一个常量是废弃常量?

运行时常量池主要回收的是废弃的常量。假如在常量池中存在字符串 ，如果当前没有任何对象引用该字符串常量的话，就说明 常量  就是废弃常量

## 如何判断一个类是无用的类?

方法区主要回收的是无用的类。

类需要同时满足下面 3个条件才能算是 “无用的类” :

* 该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例。
* 加载该类的 ClassLoader 已经被回收。
* 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类 的方法。

## 垃圾收集有哪些算法，各自的特点?

一共四种

1. 标记-清除算法

   该算法分为标记和清除阶段:首先标记出所有不需要回收的对象，在标记完成后统一回收掉所 有没有被标记的对象

2. 复制算法

   将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一 次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。

3. 标记-整理算法

   根据老年代的特点提出的一种标记算法，标记过程仍然与标记清除算法一样，但后续步骤不是 直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内 存。

4. 分代收集算法

   将堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。

## 常⻅的垃圾回收器有那些?

1. Serial 收集器

   是一个单线程收集器。它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程( "Stop The World" )，直到它收集结束。

   <u>新生代采用复制算法，老年代采用标记-整理算法。</u>

2. ParNew 收集器

   ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为(控制参数、收集算法、回收策略等等)和 Serial 收集器完全一样。

    <u>新生代采用复制算法，老年代采用标记-整理算法。</u>

3. Parallel Scavenge 收集器

   也是一个多线程收集器，它的特点就是注重吞吐量(高效率的利用 CPU)。并且这是 JDK1.8 默认收集器

   <u>新生代采用复制算法，老年代采用标记-整理算法。</u>

4. CMS 收集器

   CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。它 非常符合在注重用户体验的应用上使用。

   是 HotSpot 虚拟机第一款真正意义上的并发收集器， 它第一次实现了让垃圾收集线程与用户线程(基本上)同时工作。

    <u>收集器是一种 “标记-清除”算法实现的</u>

5. G1 收集器

    收集器的运作大致分为以下几个步骤:

   * **初始标记** **STOP THE WORLD**。初始标记**(Initial Mark)**负责标记所有能被直接可达的根对象
   * **并发标记** 每个线程每次只扫描一个分区，标记出存活对象图。还会定期检查和处理STAB全局缓冲区 列表的记录，更新对象引用信息。
   * **最终标记** **G1**需要一个暂停的时间，去处理剩下的**SATB**日志缓冲区和所有更新，找出所有未被访问的 存活对象，同时安全完成存活数据计算
   * **筛选回收**基于"标记整理"算法进行垃圾回收，并对内存整理

   

   G1 (Garbage-First) 是一款面向服务器的垃圾收集器，主要针对配备多颗处理器及大容量内存的机器。以极高概率满足 GC 停顿时间要求的同时，还具备高吞吐量性能特征。

   1. 运作期间不会产生内存碎片， **从整体上看采用的是标记整理法**，局部(两个 )上看是基于复制算法实现的，两个算法都不会产生内存碎片，收集后提供规整的可用内存，这样有利于程序的长时间运行。

   2. 在STW上建立了可预测的停顿时间模型，用户可以指定期望停顿时间， 会将停顿时间控制在用户设定的停顿时间以内。

   **为什么G1能建立可预测的停顿模型？**

   主要原因在于 G1 对堆空间的分配与传统的垃圾收集器不一样，传统的内存 分配就像我们前文所述，是连续的，分成新生代，老年代，新生代又分 Eden,S0,S1,而 G1 各代的存储地址不是连续 的，每一代都使用了 n 个不连续的大小相同的 Region，每个Region占有一块连续的虚拟内存地址。

   除了和传统的新老生代，幸存区的空间区别，Region还多了一个H，它代表Humongous，这表示这些Region存储的是 巨大对象(humongous object，H-obj)，即大小大于等于region一半的对象，这样超大对象就直接分配到了老年代，

   **防止了反复拷贝移动。那么 G1 分配成这样有啥好处呢?**

   传统的收集器如果发生 Full GC 是对整个堆进行全区域的垃圾收集，而分配成各个 Region 的话，方便 G1 跟踪各个 Region 里垃圾堆积的价值大小(回收所获得的空间大小及回收所需经验值)，这样根据价值大小维护一个优先列 表，根据允许的收集时间，优先收集回收价值最大的 Region,也就避免了整个老年代的回收，也就减少了 STW 造成 的停顿时间。同时由于只收集部分 Region,可就做到了 STW 时间的可控。

   在G1中堆被分成一块块大小相等的heap region，一般有2000多块，这些region在逻辑上 是连续的。每块region都会被打唯一的分代标 志(eden,survivor,old)。在逻辑上，eden regions 构成Eden空间，survivor regions构成Survivor空 间，old regions构成了old 空间。

   <img src="https://cdn.jsdelivr.net/gh/candyboyou/imgs/imgimage-20240712235049702.png" alt="image-20240712235049702" style="zoom:50%;" />

   