# 什么是Elastic Search？

比如说有一篇文章，每一句话都是一行。现在我们想通过关键字来搜索到这个关键字出现在哪一行，如果依次遍历文本判断这句话是含有这个关键字效率是很低的。更高效的方法就是对文本进行切分，切分成多个词也就是分词。分词结束后的每一项叫做词项，记录每一个词项和文本id。然后只要找到想要搜索的关键字对应的文本id就能找到所在的哪一行了。

## 倒排索引

但是可想而知，一篇文章的词项会多的离谱。效率是O(n)，还是太低效了。简单来说，我们可以将词项按字典顺序进行排序，通过二分查找就能找到对应的词项了。这样，我们称排好序的词项叫做Term Dictionary，而词项对应的文档id等信息的集合叫做Posting List，他们构成了一个用于搜索的数据结构，叫做倒排索引inverted index。

## Term Index

但是倒排索引还有个问题，Term Dictionary数量很大，放内存并不现实，必须放在磁盘中，但是查询磁盘又是个较慢的过程。接下来就是用Term Index进行优化。首先看follow和forward这两个单词有共同的前缀fo，这样我们把有共同前缀的单词的前缀提取出来，就能用更少的index指向更多的词了。具体操作就是将Term Dictionary中单词的前缀信息构建出来一个精简的目录树，目录树的节点中存放这些词项在磁盘中的偏移量，也就是指向磁盘中的位置。这个目录树就是Term Index。

## Stored Fields

到这里搜索功能就有了，但是有个问题，我们通过Term Index找到了Posting List，但是Posting List存放的只是文档在磁盘中的位置，还需要根据这个偏移量去磁盘中找到对应的内容。而这些内容存放的位置就是Stored Fields。

## Doc Values

经常会有一种情况，用户会根据某一个关键字进行排序，比如按照商品价格或者上架时间进行排序。但是这个字段散落在文章里，先全部找出来然后再进行排序效率也太低了。我们可以通过空间换时间，将文档中某个字段进行集中存放，比如价格有一个list，上架时间有一个list，当我们想排序的时候就拿出这个list进行针对性的排序。这个列式存储结构就是Doc Values。

## Segment

上面我们说了四种关键的数据结构：倒排索引用于搜索；Term Index用于加速搜索；Stored Fields用于存放文档的原始信息；Doc Values用于排序和聚合。这些结构共同组成了一个符合文件，也就是Segment，它是具备完整搜索功能的最小单元。

## Segment Merging

我们可以用多个文档生成一个Segment，当有新的文档要存放的话，如果还是写入旧的Segment，那要修改的东西太多了，并发读写时性能肯定受影响。所以我们规定，一个Segment生成之后就不允许修改，如果有新的文档就生成新的Segment。这样老的Segment只负责读，写的话只在新的Segment。但是Segment变多了，我们怎么知道要读取的数据在哪个Segment里面呢？并发读就好了。随着数据量增大，文件越写越多，文件句柄肯定有耗尽的那一天，可以通过不定期的合并多个Segment，这就是段合并Segment Merging。

## Lucence

多个segment就组成了一个单机文本检索库，也就是Lucence。

### Lucence的优化-高性能

多个调用方同时读写一个Lucence，肯定会导致争抢计算机资源，抢不到资源的一方就得等待，效率太低。首先可以先对存入Lucence的数据进行分类，比如分为体育新闻和财经新闻两类，每一类是一个index name，然后根据index name的数量新增Lucence的数量，将不同类的数据写入不同的Lucence中。但是每一个Lucence的数据依然可能过多，于是可以讲单个的index name的同类数据拆分成好几份，每一份都是一个shard分片，然后每一个shard分片都是一个Lucence，这样我们就可以将读写操作分摊到多个分片下，大大降低了争抢，提升了系统性能。

### Lucence的优化-高扩展性

如果分片过多，多个的Lucence在一台机器上肯定会造成CPU和内存过高，这样我们可以将多个分片分摊部署在多个机器上，这样每一个机器都是一个node。

### Lucence的优化-高可用

问题又来了，如果某一个node挂了，那么这个node下慢所有的shard分片都不能提供服务了。我们可以给分片增加几个副本在别的node上，这样分片就有primary shard和replica shard，也就是主分片和副分片。主分片会讲数据分配给副本分片。副本分片可以提供读操作还能在主分片挂了的时候升级为主分片让系统保持正常运行。

## Node角色分化

搜索架构需要支持的功能很多：既要负责集群管理，又要储存管理数据，还要处理客户端的搜索请求。如果每一个node都支持这几个功能，那数据很多的需要扩容的时候，就会顺带把其它功能也一起扩展，而其它功能完全不需要扩容，这就有些浪费了。因此我们可以将这几个功能拆开，给集群里的node赋予角色身份，不同的角色负责不同的功能。负责管理功能的叫做主节点Master Node、负责存储数据的叫做Data Node、负责处理请求的叫做Coordinate Node。

## 去中心化

上面提到了主节点，那么就说明还有一个选主的过程。首先现在所有的node都是独立的，需要有一个机制协调node之间的数据，我们很容易想到kafka那样引入一个zookeeper，但是不想引入中心节点还有其它方案吗？我们可以在每一个node节点引入魔改过的Raft模块，在节点间互相同步数据，让所有node看到的集群数据状态都是一致的。这样集群的node就能参与选主过程了，还能了解到集群中某个node是不是挂了。

## ES

![image-20240720004014094](https://cdn.jsdelivr.net/gh/candyboyou/imgs/imgimage-20240720004014094.png)

## ES的写入流程

当客户端应用发起数据写入请求，请求会先写入到协调节点，协调节点通过hash路由判断数据应该发送到数据节点里main的哪个分片，分片底层是Lucence，所以数据最终是写入到Lucence的Segemnt中。主分片写入成功后会将数据同步给副本分片，副本分片写入完成后，主分片会响应协调节点一个ack，意思是写入完成，最后协调节点响应客户端程序写入完成。

## ES的搜索流程

ES的搜索流程分为两个步骤，分别是查询阶段query phase和获取阶段fetch phase。

查询阶段：客户端会将请求先发送到集群的协调节点，协调节点根据index name的信息可以了解到index name被分成了几个分片，以及这些分片被分散在哪个数据节点上面。将请求转发到这些分片上面，搜索请求到达分片后，分片底层的Lucence库会并发搜索多个Segment，利用每个Segment内部的倒排索引获取到文档的id，并结合Doc Values获取排序信息，分片将聚合返回到协调节点。协调节点将多个分片拿到的数据进行排序聚合，舍弃大部分不需要的数据。

获取阶段：协调节点再次拿着文档id请求数据节点里面的分片，数据底层的Lucence库会从Segment内部的Stored Fields读出完整文档内容，并返回给协调节点，协调节点最终将数据返回给客户端。

## 操作

https://segmentfault.com/a/1190000010595007

https://blog.51cto.com/u_15162069/2901128

# 项目

## 为什么要用ElasticSearch？/看你用了elasticsearch 那你讲讲？/说说项目中ElasticSearch？/为什么要在项目中使用ElasticSearch？简单描述下搜索的过程？/做的时候遇到什么问题？/你这个用户数量这么少为啥不直接查Mysql？

首先我们这个系统的定位是一个提供给中石化企业内部人员使用的工具系统。这个系统提供的一个主要功能就是搜索功能，搜索化工企业、化学品、化工事故、重大危险源等信息。比如说光化工企业信息的字段大概就有八十个，而查询的关键字有十好几个，如果采用mysql的话，like的字段就很多很多了，并且只要有一个顺序不对like关键字就匹配不到，变成全表扫描了，性能变得很差了。然后搜索功能会同时搜索化工企业、化学品、化工事故、重大危险源，如果用mysql的话需要一次查十几个表，效率非常低，而ElasticSearch同时查几个索引就行了，效率也更高。然后mysql数据库并不支持分词，比如我搜齐鲁的石化企业用mysql就搜不到，而用ElasticSearch的分词插件分词就能拿到齐鲁和石化这两个词去匹配。

## 为什么ElasticSearch这么厉害不能取代MySQL?

MySQL虽然在数据全文检索方面显得有些力不从心，但是因为它的事务功能特性，可以保证不会出现脏数据。而ES并不支持事务，所以不是很适合存储原始数据。所以在工作中都是两个一起使用，一方面利用MySQL保证原始数据的安全性，另一方面利用ElasticSearch来进行全文搜索。

https://blog.csdn.net/weixin_44166705/article/details/121023662

## Mysql数据(企业数据、化工事故、企业失信、法律法规)怎么更新到ElasticSearch？

 一般情况下，新增数据的时候，很少有采取双写的方案，同时写入 MySQL 和 ES 中的。主流的技术方案，都是通过 Canal 或 DataBus 监听 MySQL 的 binlog，来把数据同步到 ES 中的。

## ElasticSearch对比mysql的好处和缺点

1. 大规模数据存储。在需要存储大量数据的场景下，Elasticsearch比MySql更适合。因为Elasticsearch可以水平扩展，可利用高效的倒排索引，可以执行复杂的聚合函数，能实现任意复杂查询条件下的全文检索需求。相比之下，MySql更适合存储小规模数据并进行事务处理。
2. 数据可扩展性。Elasticsearch天然支持分布式存储，通过简单的配置就能实现几百上千台服务器的分布式横向扩容，轻松处理 PB 级别的结构化或非结构化数据。
3. 数据一致性。在需要保证数据一致性的场景下，MySql更加适合。因为MySql是一个关系型数据库，对于数据一致性和事务处理有良好的支持。相比之下，Elasticsearch和其他分布式搜索引擎更难保证数据完全一致。

总的来说，选择合适的工具要根据具体的场景需求来做出决定。如果需要存储大量数据并进行搜索和数据分析，那么Elasticsearch更为适合。如果需要保证数据的一致性和事务处理，则MySql更为合适。如果需要处理高并发和大量数据，则也应该优先考虑Elasticsearch。

## 如果MySQL走索引，谁比较快？

进行精确检索，有些时候可能mysql要快一些，当mysql的非聚合索引引用上了聚合索引，无需回表，则速度上可能更快；es通过FST找到倒排索引的位置比获取文档id列表，再根据文档id获取文档并根据相关度进行排序。但是es还有个优势，就是es即天然的分布式能够在大量数据搜索时可以通过分片降低检索规模，并且可以通过并行检索提升效率，用filter时，更是可以直接跳过检索直接走缓存。

## 我们什么时候才要用ES呢？

在我看来可以从以下几个方法来考虑：

1. 数据规模，如果你要处理的数据高到百万甚至上亿，那你完全可以使用ES来处理大量的数据集
2. 搜索复杂度，如果你需要经常的对全文数据进行复杂的文本查询和顾虑，那ES是一个比较好的选择
3. 实时性，如果你需要快速地分析实时数据，那ES是一个合适的选择，它支持实时数据索引和查询，可以在数据到达时即时进行分析和可视化
4. 分布式和高可用性需求，如果你需要一个可扩展的，具有高可用性和容错性的数据存储和分析解决方案，那ES是一个合适的选择

## ES不适合做什么

不适合做数据库主要有以下几个方面的原因：

1. 数据的一致性和可靠性不强；
2. 不支持复杂的事务处理；
3. 数据更新和删除操作性能较低；
4. 数据安全性不足。

## 对实时性要求很高的by id查询也走ES吗？

## 为什么ES叫近实时搜索引擎，请问近实时三个字如何体现的？

默认情况下，每个分片会每秒自动刷新（refresh）一次。这就是为什么我们说 ES 是近实时搜索。文档的变化并不是立即对搜索可见，但会在一秒之内变为可见。

这是因为内存缓冲区的数据，被写入 segment 文件，且 segment 文件被写入虚拟文件系统后，才能打开这个新 segment 文件，以被检索到。因此在新 segment 文件形成之前，内存缓冲区里的数据是无法被检索到的。而 refresh 操作，默认 1s 执行一次，也既新 insert 的 doc，默认在 1s 后才能被检索到。这就是近实时的原因。

## 结果高亮怎么实现的

## ES在在项目中导入的是什么插件

analysis-hanlp

## ElasticSearch的倒排索引机制/底层是如何实现的

平常用百度、谷歌的搜索栏是如何应用ElasticSearch的

## Elasticsearch支持事务吗

ES是不支持事务的

## elasticsearch怎么实现乐观锁 

https://segmentfault.com/a/1190000021199668

## elasticsearch的里面的分片有什么作用

一个索引可以存储超出单个结点硬件限制的大量数据。比如，一个具有10亿文档的索引占据1TB的磁盘空间，而任一节点都没有这样大的磁盘空间；或者单个节点处理搜索请求，响应太慢。为了解决这个问题，Elasticsearch提供了将索引划分成多份的能力，这些份就叫做分片。当你创建一个索引的时候，你可以指定你想要的分片的数量。

## ElasticSearch是怎么进行全文检索的？模糊还是精准？

既有模糊也有精准模式。

- 模糊搜索：如sql中的like查询语句，匹配包含搜索关键字的内容。
- 精确搜索：文本内容与搜索关键字一致。
- 分词搜索：将文本先进行分词，包括搜索关键字分词和搜索内容进行分词，再匹配相关内容。

https://juejin.cn/post/6992593362675040292

## elasticSearch查询语句？/ElasticSearch想查出工资为5000，年龄在30到35之间的员工，按部门分组，写dsl？



## ES如何进行索引创建

有两种，手动创建索引和通过模版创建索引。

https://cloud.tencent.com/developer/article/2358636

## ElasticSearch插入一个json文档的流程

https://blog.csdn.net/SevenBerry/article/details/124873987 操作

## elasticsearch 为什么这么快

elasticsearch会为每个field都建立了一个倒排索引，字段值叫term，Posting list存储了所有符合某个term的文档id。然后elasticsearch为了快速找到某个特定的term，将所有的term进行排序。再采用二分查找法查找term。另外elasticsearch通过在内存里放更多的term index的一个字典树，从term index查到对应的term dictionary之后，再去磁盘上找term，大大减少了磁盘随机读的次数，查询效率大大提升。

## es写数据过程

elasticsearch检索关于文章与搜索关键词重合的权重算法

## 如何保证es和MySQL一致性

我们采用的是在代码中，对数据库和ES进行双写，并且先操作本地数据库，后操作ES，而且还需要把两个操作放到一个事务中这么来的。另外，我了解到有MQ异步消费和监听binlog同步两种方案，MQ异步消费就是先操作数据库，然后数据库和ES各自有一个监听者，监听消息之后自去做数据变更，如果失败了就基于消息的重试在重新执行。监听binlog同步就是利用数据库变更时产生的binlog来更新ES。通过监听binlog来更新ES中的数据，也有成熟的框架可以做这样的事情。

## 如果用消息队列异步写入的话，消息丢失怎么办



海量数据如何写入es；实习中如何处理多线程的情况

提到接着话题顺势到了我的分布式锁，因为我的分布式锁是由Redisson实现的，那么Redisson也是有延迟队列的但是我不知道，他问我redis如何实现延迟队列，我说轮询+检测过期时间，感觉面试官有点被逗笑了，就说Redisson就有延迟队列。说我对所用的中间件或者框架都是只知道个大概，有顺着分布式锁问分布式锁如何续约（Redisson自己有个续约机制），以及还有什么可以做分布式锁（我答数据库），接着问我是项目里怎么上分布式锁。我说是写了两个注解，用AOP来调用Redisson处理，接着又问我注解怎么写的，我说有Lock和Key两个注解，Lock就是对方法上锁，Key就是提供上锁的参数。它又说我的锁的颗粒度有点大了，锁的是整个方法，突然问我知道SpEL吗。我说知道一丢丢，因为我的Key就是这么写的(expr = "#{userId + '::' + bookId}")，顺着又往下问，说你没用过Mybatis吗，用过Mybatis的话SpEL怎么只会一点点。我说我都用basemapper的，很少手写xml了。

中间还问了我xxljob的优点什么什么的，这里不展开说了。

