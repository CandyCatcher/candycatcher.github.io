{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"Hello World","slug":"hello-world","date":"2021-09-12T15:01:48.106Z","updated":"2021-09-12T15:01:48.106Z","comments":true,"path":"2021/09/12/hello-world/","link":"","permalink":"http://example.com/2021/09/12/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Spring简介","slug":"2020-04-14-Spring——简介","date":"2020-04-14T09:37:00.000Z","updated":"2020-05-27T14:58:36.000Z","comments":true,"path":"2020/04/14/2020-04-14-Spring——简介/","link":"","permalink":"http://example.com/2020/04/14/2020-04-14-Spring%E2%80%94%E2%80%94%E7%AE%80%E4%BB%8B/","excerpt":"都说Spring是最流行的java框架，但是Spring框架是什么呢？为什么要使用Spring？Spring就是一个依赖注入容器，创建bean并维护bean之间的关系。在Spring框架上可添加并维护web层，持久层，业务层，dao层，帮助我们更快，更方便地构建Java应用程序","text":"都说Spring是最流行的java框架，但是Spring框架是什么呢？为什么要使用Spring？Spring就是一个依赖注入容器，创建bean并维护bean之间的关系。在Spring框架上可添加并维护web层，持久层，业务层，dao层，帮助我们更快，更方便地构建Java应用程序 为什么使用Spring? 引用知乎上大宽宽的回答： JavaEE是一组建立在JavaSE之上的标准，解决企业级开发中的一系列问题。请特别留意，它仅仅是个标准，是对一系列接口的约定，众多厂商围绕这个标准做实现。如JBoss，WebSphere等。第一个版本的JavaEE 1.2在1999年被发布，到2017年的JavaEE 8，已经经历了将近20年。 那么JavaEE都有哪些标准，解决了什么问题呢？我这里简单列举一下主要的标准： Servlet：定义了如何处理Web请求，这个相信大家最熟悉 Java Server Faces：定义了如何使编写Web界面 JAX-RS：定义了如何编写RESTFul的接口 EJB：定义了如何编写“企业Bean” JPA：定义了如何编写ORM和数据存取 JTA：定义了如何编写事务相关的代码 JMS：定义了如何编写消息队列程序 CDI：定义了如何编写依赖注入 JAX：定义了如何编写XML程序 JAX-WS: 定义了如何编写基于XML的网络服务，即SOAP …… 看到这些，你可能机会发现，你平时其实经常使用其中一些标准接口，即便你认为你在用Spring。 什么是Spring呢？Spring最早可以追溯到2002～2004年。在那几年作者Rod Johnson出版了两本书：“Expert One-on-One J2EE Design and Development“和“Expert One-on-One J2EE Development without EJB“，和最初几个版本的Springframework。 早期的Spring定位于解决J2EE在实际使用上的一系列问题，因为JavaEE的API实在是太难用了。Rod估计是趟了不少大坑，于是总结了一套最佳实践，并总结到了一套框架里。其中最重要的，就是所谓IoC（控制反转）。 经过多年发展，Spring发布了很多组件： spring-core：Spring的Bean的管理，控制反转和程序上下文 spring-mvc: web开发中的model-view-controller spring-data: 数据层访问和封装 spring-boot: spring全家桶自助配置和部署管理工具 spring-batch：一个简单的批处理框架 spring-cloud：支持与许多云服务接口的整合 spring-security：认证和权限管理 …… spring中其实大量使用或者实现了JavaEE标准。比如spring-mvc是在servlet基础之上的封装。spring本身并不提供容器，而是支持使用任何支持servlet标准的容器（如tomcat，jetty等）。spring-data也实现了JPA，通过标准接口对进行CRUD等。 归根到底Spring只是想更好的解决实际问题。JavaEE的实现做得好的就用，做得不好的用比较恰当的方式独立实现或者封装。俗称“接地气”。 其实一句话总结，Spring是基于并优化后的j2EE框架。按照我的理解，在Spring出现之前，人们都是使用Sun公司规定的EJB进行Java项目的开发，但是EJB过于复杂、繁重，为了解决j2EE的问题，Spring 被开发出来。由于Spring站在非常实用的角度帮助程序员解决了很多不需要程序员搞和程序员一直重复搞的问题，所以越来越流行。 Spring的优点 松耦合 大名叫:依赖注入。 说白了就是根据配置文件动态组装复杂对象。 或许有人又问, 我就是用程序组合也很简单啊。 是的，你程序组装简单业务的是很简单。如果组装的对象里面包含了Ejb，包含了JMS，包含了远程RMI那就没有这样组装简单了。 AOP——面向切面编程 这个功能我们自己是不好设计的。这个功能大家也都知道是干什么的，例如方法的事务管理、用户安全验证、 日志记录等等。为了避免将更多的代码放进方法中去。spring使用这个AOP来监控符合你配置的正则表达式的方法名字。并允许在执行这个方法的前后执行你的方法。这个是建立在spring上下文框架下的一个功能。原理是映射机制。如果没有上下文是不好搞的。​虽然spring AOP对于大多程序员就足够了。但与AspectJ相比，他只能是功能比较弱的解决方案。AspectJ提供了SpringAOP不可能实现的多种切点类型。如果不够用，你可以引入AspectJ。来帮助你做更多的工作。 Bean工厂节省了您自己构造工厂 你不用再自己构造工厂了，不用再用自己构造单例模式了，不用自己再关心对象的创建了，不用new对象了， 一切都直接从上下文的框架中取就行了。 框架会帮助你构造你需要的对象。 你只需要跟上下文打交道就可以了。当然，你多出了装配的工作。 Spring 针对不同的数据库访问模式提供了不同的模板 分别适用于不同的持久机制，节省了重复代码。 包括: 针对JCA CCI的、 针对JDBC的链接，支持命名参数的JDBC的链接、 Hebernate的、针对iBATIS sqlMap的、Oraclede TopLink的。这些模板使用方式的统一降低了程序员使用不同数据库的成本。模板的使用让你只关心数据的准备，而看不到那些样板代码，其实那些样板代码都还在，只是被巧妙的隐含到了template中了。例如: List list = jdbcTemplate.query(“select * from table1”,new Object[]&#123;“a”,”b”&#125;,new RowMapper()&#123;…..&#125;); 。 Spring是什么 一句话总结，spring就是一个依赖注入（IOC）容器**，创建bean并维护bean之间的关系。在spring框架上可添加并维护web层，持久层，业务层，dao层，帮助我们更快，更方便地构建Java应用程序。 依赖注入什么是依赖注入呢？ 构造函数注入1234567891011121314151617181920&lt;!--构造方法属性注入--&gt;&lt;bean id=&quot;car1&quot; class=&quot;demo2.Car&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;bmw&quot;/&gt; &lt;constructor-arg name=&quot;price&quot; value=&quot;10000000&quot;/&gt;&lt;/bean&gt;&lt;!--依赖set方法的属性注入--&gt;&lt;bean id=&quot;car2&quot; class=&quot;demo2.Car2&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;audi&quot;/&gt; &lt;property name=&quot;price&quot; value=&quot;100000000&quot;/&gt;&lt;/bean&gt;&lt;!--p名称空间属性注入--&gt;&lt;bean id=&quot;car3&quot; class=&quot;demo2.Car2&quot; p:name=&quot;qq&quot; p:price=&quot;20000&quot;&gt;&lt;/bean&gt;&lt;!--SpEL的属性注入--&gt;&lt;bean id=&quot;carUser&quot; class=&quot;demo2.CarUser&quot;&gt; &lt;property name=&quot;carname&quot; value=&quot;#&#123;&#x27;benz&#x27;&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;#&#123;&#x27;sam&#x27;&#125;&quot;/&gt;&lt;/bean&gt; Spring的分模块开发 在一个配置文件中引入多个配置文件 1&lt;import resource=&quot;其他子配置文件&quot;&gt; 加载配置文件时，加载多个 1ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-config.xml, spring-config2.xml&quot;); AOP什么是AOP 面向切面编程（AOP是Aspect Oriented Program的首字母缩写） ，我们知道，面向对象的特点是继承、多态和封装。而封装就要求将功能分散到不同的对象中去，这在软件设计中往往称为职责分配。实际上也就是说，让不同的类设计不同的方法。这样代码就分散到一个个的类中去了。这样做的好处是降低了代码的复杂程度，使类可。但是人们也发现，在分散代码的同时，也增加了代码的重复性。什么意思呢？比如说，我们在两个类中，可能都需要在每个方法中做日志。按面向对象的设计方法，我们就必须在两个类的方法中都加入日志的内容。也许他们是完全相同的，但就是因为面向对象的设计让类与类之间无法联系，而不能将这些重复的代码统一起来。也许有人会说，那好办啊，我们可以将这段代码写在一个独立的类独立的方法里，然后再在这两个类中调用。但是，这样一来，这两个类跟我们上面提到的独立的类就有耦合了，它的改变会影响这两个类。那么，有没有什么办法，能让我们在需要的时候，随意地加入代码呢？这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。 一般而言，我们管切入到指定类指定方法的代码片段称为切面，而切入到哪些类、哪些方法则叫切入点。有了AOP，我们就可以把几个类共有的代码，抽取到一个切片中，等到需要时再切入对象中去，从而改变其原有的行为。 这样看来，AOP其实只是OOP的补充而已。OOP从横向上区分出一个个的类来，而AOP则从纵向上向对象中加入特定的代码。有了AOP，OOP变得立体了。如果加上时间维度，AOP使OOP由原来的二维变为三维了，由平面变成立体了。从技术上来说，AOP基本上是通过代理机制实现的。AOP在编程历史上可以说是里程碑式的，对OOP编程是一种十分有益的补充。 123456789101112131415161718192021&lt;context:annotation-config/&gt;&lt;bean id=&quot;userDao&quot; class=&quot;demo4.UserDaoImpl&quot;/&gt;&lt;!--配置切面类--&gt;&lt;bean id=&quot;myAspectXml&quot; class=&quot;demo4.MyAspectXml&quot;/&gt;&lt;!--进行aop配置--&gt;&lt;aop:config proxy-target-class=&quot;true&quot;&gt; &lt;!--配置切入点表达式：哪些类的哪些方法需要增强--&gt; &lt;aop:pointcut id=&quot;point1&quot; expression=&quot;execution(* demo4.UserDaoImpl.save(..))&quot;/&gt; &lt;aop:pointcut id=&quot;point2&quot; expression=&quot;execution(* demo4.UserDaoImpl.update(..))&quot;/&gt; &lt;aop:pointcut id=&quot;point3&quot; expression=&quot;execution(* demo4.UserDaoImpl.delete(..))&quot;/&gt; &lt;aop:pointcut id=&quot;point4&quot; expression=&quot;execution(* demo4.UserDaoImpl.find(..))&quot;/&gt; &lt;!--配置切面--&gt; &lt;aop:aspect id=&quot;aspect&quot; ref=&quot;myAspectXml&quot;&gt; &lt;aop:before pointcut-ref=&quot;point3&quot; method=&quot;before&quot;/&gt; &lt;aop:around method=&quot;around&quot; pointcut-ref=&quot;point2&quot;/&gt; &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;point4&quot;/&gt; &lt;aop:after-returning method=&quot;end&quot; pointcut-ref=&quot;point1&quot;/&gt; &lt;aop:after-returning method=&quot;end&quot; pointcut-ref=&quot;point2&quot;/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 实现类 123456789101112131415161718192021public class UserDaoImpl implements UserDao &#123; @Override public void save() &#123; System.out.println(&quot;save....&quot;); &#125; @Override public void update() &#123; System.out.println(&quot;update....&quot;); &#125; @Override public void delete() &#123; System.out.println(&quot;delete....&quot;); &#125; @Override public void find() &#123; System.out.println(&quot;find....&quot;); &#125;&#125; 增强类 123456789101112131415161718192021222324public class MyAspectXml &#123; //前置增强 public void before() &#123; System.out.println(&quot;前置增强=================&quot;); &#125; //后置增强 public void after() &#123; System.out.println(&quot;后置增强+++++++++++++++++&quot;); &#125; //环绕增强 public void around(ProceedingJoinPoint joinPoint) throws Throwable &#123; System.out.println(&quot;环绕增强-----------------1&quot;); joinPoint.proceed(); System.out.println(&quot;环绕增强-----------------2&quot;); &#125; //最终增强 public void end() &#123; System.out.println(&quot;最终通知、、、、、、、、、、&quot;); &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/tags/Spring/"}]},{"title":"转载：曾经风光无限的jsp技术，为什么现在很少有人用了呢？","slug":"2020-04-14-转载：曾经风光无限的jsp技术，为什么现在很少有人用了呢？","date":"2020-04-14T09:37:00.000Z","updated":"2020-05-26T07:14:30.000Z","comments":true,"path":"2020/04/14/2020-04-14-转载：曾经风光无限的jsp技术，为什么现在很少有人用了呢？/","link":"","permalink":"http://example.com/2020/04/14/2020-04-14-%E8%BD%AC%E8%BD%BD%EF%BC%9A%E6%9B%BE%E7%BB%8F%E9%A3%8E%E5%85%89%E6%97%A0%E9%99%90%E7%9A%84jsp%E6%8A%80%E6%9C%AF%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E7%8E%B0%E5%9C%A8%E5%BE%88%E5%B0%91%E6%9C%89%E4%BA%BA%E7%94%A8%E4%BA%86%E5%91%A2%EF%BC%9F/","excerpt":"jsp技术作为曾经一度火爆的技术，在最近几年确实使用率越来越低了，这篇文章带你一块探究一下jsp的从生到死。","text":"jsp技术作为曾经一度火爆的技术，在最近几年确实使用率越来越低了，这篇文章带你一块探究一下jsp的从生到死。 jsp技术的诞生在很久很久以前，那时候我们的开发都是通过servlet来完成的，这个servlet是什么呢？我们先来认识一下： servlet用Java语言编写的服务器端程序。主要功能是和浏览器进行交互，生成页面展示。 长下面这个样子： 123456789101112131415public class HelloWorld extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(&quot;text/html&quot;); PrintWriter out = response.getWriter(); out.println(&quot;&lt;html&gt;&quot;); out.println(&quot;&lt;head&gt;&quot;); out.println(&quot;&lt;title&gt;Hello World&lt;/title&gt;&quot;); out.println(&quot;&lt;/head&gt;&quot;); out.println(&quot;&lt;body&gt;&quot;); out.println(&quot;&lt;h1&gt;Hello World!&lt;/h1&gt;&quot;); out.println(&quot;&lt;/body&gt;&quot;); out.println(&quot;&lt;/html&gt;&quot;); &#125; &#125; 我们可以看到前端所展示的页面，需要我们servlet去一个标签一个标签去生成，如果一个页面超级复杂，动不动几千行代码，那这个servlet效率也就太低了。而且整个servlet代码也会十分臃肿而且可读性非常差。 这时候怎么办呢？sun公司很早就意识到了这个问题，于是便倡导很多公司一块来创建了一种能够动态生成html的新技术，不久之后jsp便诞生了。有效率的解决了上面servlet所出现的问题。 jsp的发展既然jsp技术能够解决刚刚servlet代码里面所出现的技术，我们来看一下是如何解决的：在这里我们举一个小例子，就是前端jsp向服务器servlet发送请求图书页面的功能。 首先我们看一下servlet： 123456789101112131415public class List_book extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //声明一个ArrayList.用来存放Book类中的数据 ArrayList&lt;Book&gt; list = new ArrayList&lt;Book&gt;(); for(int i=0;i&lt;10;i++)&#123; Book book = new Book(); book.setName(res.getString(&quot;name&quot;+i)); book.setAuthor(res.getString(&quot;author&quot;+i)); list.add(book); &#125; //将list数据发送到.jap文件中 request.getRequestDispatcher(&quot;ListBook.jsp&quot;).forward(request, response); &#125; &#125; 我们会发现，现在的servlet没有一点html代码了。我们只需要把数据交给jsp。此时我们的页面展示就交给jsp来做了。现在我们来看一下jsp长什么样子： 12345678910111213141516171819202122232425&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;utf-8&quot;%&gt;&lt;%String path = request.getContextPath();%&gt; &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;pragma&quot; content=&quot;no-cache&quot;&gt; &lt;meta http-equiv=&quot;description&quot; content=&quot;This is my page&quot;&gt; &lt;script&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;% ArrayList list = (ArrayList) request.getAttribute(&quot;list&quot;); %&gt; &lt;h2 align = &quot;center&quot;&gt;图书列表&lt;/h2&gt; &lt;table border = 1px align = &quot;center&quot;&gt; &lt;tr&gt;&lt;th&gt;图书名称&lt;/th&gt;&lt;th&gt;图书作者&lt;/th&gt;&lt;/tr&gt; &lt;!-- 继续使用jsp语句 循环放入存放于list中的Book实体类中的数据 --&gt; &lt;% for(int i = 0;i&lt;list.size();i++)&#123; Book book =(Book) list.get(i);%&gt; &lt;tr&gt;&lt;th&gt;&lt;%=book.getName() %&gt;&lt;/th&gt;&lt;th&gt;&lt;%=book.getAuthor()%&gt;&lt;/th&gt;&lt;tr&gt; &#125; %&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; 这就是jsp，我们可以在html页面中写一些java代码。对于我们程序员来说，在开发当中静态的页面我们只需要用html和css写一些标签来展示即可，对于那些动态的部分我们就可以使用java代码。 那么jsp和servlet是不是就是这种协作的关系，本质上有什么区别呢？ 其实jsp只是servlet的一种特殊形式，每一个jsp页面就是一个servlet实例，通俗一点的话来说：jsp就是servlet，只不过servlet把一些业务功能剥离开来交给了或者是形成了jsp。明白了吧。在我们的项目编译的时候就是把jsp编译成了servlet。 你们会发现，这样做其实挺好的，市场也验证了一切，很快jsp技术流行开来，可是随着时间的流逝，业务越来越复杂，jsp也开始跟不上时代了。 jsp的危机我们先看一个对话场景： java程序员：终于写完了功能，是时候在界面上展示了。前端程序员：你功能写完了，我没有数据，在页面什么没法展示呀java程序员：数据我写好了，你在jsp中调用XX方法就能获取了，前端程序员：我已经在jsp中写好了这个方法，你为什么自己写了？于是乎，无穷无尽的争吵还在继续当中。 这就是jsp的弊端，为什么呢？我们可以来总结一下： （1）动态和静态资源放在一起，一旦服务器出现状况，前后台一起玩完，用户体验极差。 （2）一旦jsp出现了问题，就需要前端后端发开人员一块来分析解决，效率低。 （3）jsp无法使用nginx等。 （4）jsp页面复杂，难以修改。 （5）第一次加载jsp需要编译成servlet，时间久，而且业务量大的时候，jsp负担太大。 （6）jsp对于开发人员简直就是一个挥之不去的痛，太难了！！！ 鉴于以上缺点，于是另外一套机制横空出世了，这就是前后端分离。什么是前后端分离呢？ 前后端分离其实就是后端工程师只关注于后端页面的开发，不再处理前端问题。前端工程师只关注于自己的页面开发。需要数据交互的时候，两者会有一份接口文档。 就这样这种思想架构很快的流行开来，这也就是为什么jsp落寞的真正原因。从此java从jsp转向了restful结构，springMCV也开始流行开来，并逐渐占领了市场。前后端分离有什么优点呢？我们来总结一下： （1）动态和静态资源分开存储。 （2）出现bug能很快定位是前端还是后端。 （3）支持nginx。在高并发状态下极其优秀。 （4）直接请求页面，不用编译，速度效率都提上来了。 （5）从此前端和后端是相亲相爱的一家人了！！！！ jsp的落幕又随着时间的推移，jsp的时代基本上一去不复返了，因为我们又走入了移动互联时代，这时候的客户端可不是前端页面了，还包括手机、汽车、电视等等各种设备，这种情况下，前后端必须要分离了。jsp基本上彻底告别了它的舞台。 技术总是在不断地发展和完善，只有技术的革新才会带来社会的进步。","categories":[{"name":"Web","slug":"Web","permalink":"http://example.com/categories/Web/"}],"tags":[{"name":"Jsp","slug":"Jsp","permalink":"http://example.com/tags/Jsp/"},{"name":"Web","slug":"Web","permalink":"http://example.com/tags/Web/"}]},{"title":"JDBC的理解与应用","slug":"2020-04-10-JDBC的理解与应用","date":"2020-04-10T05:47:00.000Z","updated":"2020-05-26T07:21:47.000Z","comments":true,"path":"2020/04/10/2020-04-10-JDBC的理解与应用/","link":"","permalink":"http://example.com/2020/04/10/2020-04-10-JDBC%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E5%BA%94%E7%94%A8/","excerpt":"JDBC是什么？主要使用的一些接口？以及连接池的初步理解与使用","text":"JDBC是什么？主要使用的一些接口？以及连接池的初步理解与使用 JDBC是什么 ​ JDBC（Java Data Base Connectivity， Java访问数据库的解决方案）是一种用于执行SQL语句的Java API，它由一组用Java语言编写的类和接口组成（自己没有实现），不同的数据库厂商根据各自数据库的特点去实现这些接口，这样用相同的方式访问不同的数据库，以实现与具体数据库无关的Java操作界面。java.sql包中装的就是jdbc驱动。 JDBC的架构 JDBC主要的接口Connection接口12345Class.forName(&quot;com.mysql.jdbc.driver&quot;) Connection conn = DriverManager.getConnecti语言on( &quot;jdbc:[mysql://localhost:3306/mysql](https://link.jianshu.com?t=mysql://localhost:3306/mysql)&quot;, &quot;root&quot;,&quot;&quot;); 根据url连接参数找到与之匹配的Driver对象,调用其方法获取连接 NOTE: Connection只是接口！真正的实现是由数据库厂商提供的驱动包完成的 Statement接口​ Statement 是 Java 执行数据库操作的一个重要接口，用于在已经建立数据库连接的基础上，向数据库发送要执行的SQL语句。Statement对象，用于执行不带参数的简单SQL语句，即静态SQL语句。 1234Statement stme=conn.createStatement();boolean flag = stmt.execute(sql); //DDL 数据库定义语言int falg = stmt.executeUpdate(sql); //DML 数据更改语言ResuleSet rs = stmt.executeQuery(sql); //DQL 数据查询语言 PreparedStatement接口​ PreparedStatement继承于Statement，它的实例包含已编译的 SQL 语句，这就是使语句“准备好”。PreparedStatement 对象中的 SQL 语句可具有一个或多个 IN 参数。IN参数的值在 SQL 语句创建时未被指定，而是为每个 IN 参数保留一个问号?作为占位符。每个问号的值必须在该语句执行之前，通过setXXX()方法来提供。简言之，Statement执行静态SQL语句，而它的子类PreparedStatement执行预编译SQL，即可传入参数。 ​ 两者相比之下，PreparedStatement有以下优势： 预编译处理，可动态执行SQL语句。很明显，SQL语句的预编译，使用占位符?去代替未知数据，因而一个句子可以执行多种不同的SQL，而Statement需要重新书写SQL语句，笨重。 速度快，执行效率高。SQL语句会预编译在数据库系统中。执行计划同样会被缓存起来，它允许数据库做参数化查询。使用预处理语句比普通的查询更快，因为它做的工作更少（数据库对SQL语句的分析，编译，优化已经在第一次查询前完成了）。我们要利用预编译的特性，比如第一种查询和第二种查询，第二种才是预编译形式，而第一种其实是恢复了父类Statement的做法： 1234567//第一种方式，追加字符串：没有进行预编译，所以效率低String loanType = getLoanType();PreparedStatement prestmt = conn.prepareStatement(&quot;select banks from loan where loan_type=&quot; + loanType);//第二种方式，使用占位符，进行预编译，效率高（推荐）PreparedStatement prestmt = conn.prepareStatement(&quot;select banks from loan where loan_type=?&quot;);prestmt.setString(1,loanType); 可防止SQL注入式攻击。静态SQL语句说到底还是字符串，所以存在拼字符串的而带来的注入式SQL攻击风险。比如某个网站的登录验证SQL查询代码为： 1String sql = &quot;SELECT * FROM users WHERE name = &#x27;&quot; + userName + &quot;&#x27; and pw = &#x27;&quot;+ passWord +&quot;&#x27;;&quot; 验证需要用户输入用户名和密码，正确则执行查询语句（登录），但如果这样输入： 12userName = &quot;1&#x27; OR &#x27;1&#x27;=&#x27;1&quot;;passWord = &quot;1&#x27; OR &#x27;1&#x27;=&#x27;1&quot;; 那么执行语句就变成了： 1String sql = &quot;SELECT * FROM users WHERE name = &#x27;1&#x27; OR &#x27;1&#x27;=&#x27;1&#x27; and pw = &#x27;1&#x27; OR &#x27;1&#x27;=&#x27;1&#x27;;&quot; 这样，where语句恒为真，就能实现无账号登录。此外便可能被恶意修改甚至删除数据表。而使用PreparedStatement的参数化的查询可以阻止大部分的SQL注入。PreparedStatement不是将参数简单拼凑成sql，而是做了一些预处理，将参数转换为string，两端加单引号，将参数内的一些特殊字符（换行，单双引号，斜杠等）做转义处理，这样就很大限度的避免了sql注入。且占位符?不允许多值，只能填入一个值，因此就算参数中含有破坏性的指令，也不会被数据库所运行。 说了那么多，PreparedStatement如何获取呢？PreparedStatement是和连接对象Connection关联的，所以我们需要使用Connection对象的PreparedStatement（sql）方法进行获取： 12String sql = &quot;select * from user where name=? and ange=?&quot;;//预处理，需要我们先写好sql语句PreparedStatement ps = conn.preparedStatement(sql);//conn是连接对象，参数为sql语句 ResultSet接口 执行查询SQL语句后返回的结果集,由ResultSet接口接收 常用处理方式：遍历/判断是否由结果（登陆） 12345String sql = &quot;select * from emp&quot;;ResuleSet rs = stmt.executeQuery(sql);while(rs.next()) &#123; System.out.println(rs.getInt(&quot;empno&quot;) + &quot;,&quot;+ rs.getString(&quot;ename&quot;));&#125; 查询的结果存放在ResuleSet对象的一系列行中 ResultSet对象的最初位置在行首 Result.next()方法用来在行间移动 Result.getXXX()方法用来取的字段的内容 JDBC工作过程JDBC工作过程： 加载驱动，建立连接 创建语句对象 执行SQL语句 处理结果集 关闭连接 123456789101112131415161718192021222324252627public class Test &#123; public static void main(String[] args) throws Exception &#123; // TODO Auto-generated method stub // 1 加载驱动 // 把com.mysql.jdbc.Driver这份字节码加载进JVM // 当一份字节码加载进JVM的时候，就会执行字节码文件中的静态代码块 // 这里加载该字节码之后会实例化一个驱动器 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); String url = &quot;jdbc:mysql://localhost:3306/jdbc_db&quot;; String username = &quot;root&quot;; String password = &quot;1234&quot;; // 2 连接数据库 Connection connection = DriverManager.getConnection(url, username, password); // 3 创建sql语句 String sql = &quot;create table stu (id int , name varchar(20), age int)&quot;; // 4 执行sql语句 Statement st = connection.createStatement(); int row = st.executeUpdate(sql); // 5 释放 st.close(); connection.close(); &#125;&#125; 连接池技术为什么要使用连接池 资源重用 (连接复用) 由于数据库连接得到重用，避免了频繁创建、释放连接引起的大量性能开销。在减少系统消耗的基础上，增进了系统环境的平稳性（减少内存碎片以级数据库临时进程、线程的数量） 更快的系统响应速度 数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于池内备用。此时连接池的初始化操作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而缩减了系统整体响应时间。 新的资源分配手段 对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接的配置，实现数据库连接技术。 统一的连接管理，避免数据库连接泄露 在较为完备的数据库连接池实现中，可根据预先的连接占用超时设定，强制收回被占用的连接，从而避免了常规数据库连接操作中可能出现的资源泄露 连接池参数 常用参数有： 初始连接数 最大连接数 最小连接数 每次增加的连接数 超时时间 最大空闲连接 最小空闲连接 根据应用需要，设置合适的值 连接池中连接的释放与使用原则 应用启动时，创建初始化数目的连接 当申请时无连接可用或者达到指定的最小连接数，按增量参数值创建新的连接 为确保连接池中最小的连接数的策略 动态检查：定时检查连接池，一旦发现数量小于最大连接数,则补充相应的新连接,保证连接池正常运转 静态检查：空闲连接不足时,系统才检测是否达到最小连接数 按需分配，用过归还，空闲超时释放，获取超时报错 连接池也只是接口，具体实现由厂商来完成 c3p0数据库连接池的使用 通过属性文件获取连接池参数 1234567891011private static ComboPooledDataSource comboPooledDataSource = new ComboPooledDataSource(&quot;db.properties&quot;);//加载db.properties数据库配置文件public Connection getConnection() throws SQLException&#123; try &#123; //获取一个数据库链接 return comboPooledDataSource.getConnection(); &#125; catch (SQLException e) &#123; e.printStackTrace(); throw e; &#125;&#125; 使用硬编码连接 123456789// 1. 创建了一个核心类对象 :ComboPooledDataSource dataSource = new ComboPooledDataSource();// DataSource dataSource = new ComboPooledDataSource();// 2. 设置了四个核心参数dataSource.setDriverClass(&quot;com.mysql.cj.jdbc.Driver&quot;);dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/mydb?serverTimezone=UTC&amp;characterEncoding=UTF-8&quot;);dataSource.setUser(&quot;root&quot;);dataSource.setPassword(&quot;123456&quot;); 说一下Datasource： 当调用DataSource.getConnection()时，其实它调用的是DriverManager.getConnection(url, user, password)来获取一个Connection，Connection使用完后被close，断开与数据库的连接，我们称这总方式是直连数据库，因为每次都需要重新建立与数据库之间的连接，而并没有把之前的Connection保留供下次使用。 可以说这种方式就是使用了连接池技术。DataSource内部封装了一个连接池，当你获取DataSource的时候，它已经悄悄的与数据库建立了多个Connection，并将这些Connection放入了连接池，此时调用DataSource.getConnection()它从连接池里取一个Connection返回，Connection使用完后被close，但这个close并不是真正的与数据库断开连接，而是告诉连接池”我”已经被使用完，”你”可以把我分配给其它”人”使用了。就这样连接池里的Connection被循环利用，避免了每次获取Connection时重新去连接数据库。","categories":[{"name":"JDBC","slug":"JDBC","permalink":"http://example.com/categories/JDBC/"}],"tags":[{"name":"JDBC","slug":"JDBC","permalink":"http://example.com/tags/JDBC/"}]},{"title":"SpringMVC的理解与应用(一)","slug":"2020-02-25-SpringMVC的简单理解与应用(一)","date":"2020-02-25T08:00:00.000Z","updated":"2020-05-26T07:12:16.000Z","comments":true,"path":"2020/02/25/2020-02-25-SpringMVC的简单理解与应用(一)/","link":"","permalink":"http://example.com/2020/02/25/2020-02-25-SpringMVC%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E4%B8%8E%E5%BA%94%E7%94%A8(%E4%B8%80)/","excerpt":"","text":"SpringMVC的工作原理 核心架构的具体流程步骤 首先用户发送请求——&gt;DispatcherServlet，前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行处理，作为统一访问点，进行全局的流程控制； DispatcherServlet——&gt;HandlerMapping， HandlerMapping 将会把请求映射为HandlerExecutionChain 对象（包含一个Handler 处理器（页面控制器）对象、多个HandlerInterceptor 拦截器）对象，通过这种策略模式，很容易添加新的映射策略； DispatcherServlet——&gt;HandlerAdapter，HandlerAdapter 将会把处理器包装为适配器，从而支持多种类型的处理器，即适配器设计模式的应用，从而很容易支持很多类型的处理器； HandlerAdapter——&gt;处理器功能处理方法的调用，HandlerAdapter 将会根据适配的结果调用真正的处理器的功能处理方法，完成功能处理；并返回一个ModelAndView 对象（包含模型数据、逻辑视图名）； ModelAndView的逻辑视图名——&gt; ViewResolver， ViewResolver 将把逻辑视图名解析为具体的View，通过这种策略模式，很容易更换其他视图技术； View——&gt;渲染，View会根据传进来的Model模型数据进行渲染，此处的Model实际是一个Map数据结构，因此很容易支持其他视图技术； 返回控制权给DispatcherServlet，由DispatcherServlet返回响应给用户，到此一个流程结束。 ​ 首先， Spring MVC 框架是围绕着 Dispatcherservlet 而工作的，所以这个类是其最为重要的类。从它的名字来看，它是一个 servlet ，那么根据 Java EE 基础的学习，我们知道它可以拦截 Http发送过来的请求，在 servlet 初始化（调用 init 方法）时， spring MVC 会根据配置，获取配置信息，从而得到统一资源标识符（ URI , Uniform Resource Identifier ）和处理器（ Handler ）之间的映射关系（ HandlerMapping )。为了更加灵活和增强功能， Spring MVC 还会给处理器加入拦截器，所以还可以在处理器执行前后加入自己的代码，这样就构成了一个处理器的执行链（ HandlerExecutionChain ) ，并且根据上下文初始化视图解析器等内容，当处理器返回的时候就可以通过视图解析器定位视图，然后将数据模型渲染到视图中，用来响应用户的请求了。 ​ 当一个请求到来时， Dispatcherservlet 首先通过请求和事先解析好的 HandlerMapping 配置，找到对应的处理器（ Handler ) ，这样就准备开始运行处理器和拦截器组成的执行链，而运行处理器需要有一个对应的环境，这样它就有了一个处理器的适配器 ( HandlerAdaPter ) ，**通过这个适配器就能运行对应的处理器及其拦截器**，这里的处理器包含了控制器的内容和其他增强的功能，在处理器返回模型和视图给 DispacherServlet 后， **Dispacherservlet 就会把对应的视图信息传递给视图解析器（ viewResolver ）**。注意，这一步取决于是否使用逻辑视图，如果是逻辑视图，那么视图解析器就会解析它，然后把模型渲染到视图中去，最后响应用户的请求；如果不是逻辑视图，则不会进行处理，而是直接通过视图渲染数据模型。这就是一个 Spring MvC 完整的流程，它是一个松散的结构，所以可以满足各类请求的需要，为此它也实现了大部分的请求所需的类库，拥有较为丰富的类库供我们使用，所以流程中的大部分组件并不需要我们去实现，只是我们应该知道整个流程，熟悉它们的使用就可以构建出强大的互联网系统了。 组件1. 前端控制器DispatcherServlet（不需要工程师开发），由框架提供 作用：接收请求，响应结果，相当于转发器，中央处理器。有了dispatcherServlet减少了其它组件之间的耦合度。 用户请求到达前端控制器，它就相当于mvc模式中的controller，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。 2. 处理器映射器HandlerMapping（不需要工程师开发），由框架提供 作用：根据请求的url查找Handler HandlerMapping负责根据用户请求找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。 3. 处理器适配器HandlerAdapter 作用：按照特定规则（HandlerAdapter要求的规则）去执行Handler 通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。 4. 处理器Handler(需要工程师开发) 注意：编写Handler时按照HandlerAdapter的要求去做，这样适配器才可以去正确执行Handler Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。 由于Handler涉及到具体的用户业务请求，所以一般情况需要工程师根据业务需求开发Handler。 5. 视图解析器View resolver(不需要工程师开发)，由框架提供 作用：进行视图解析，根据逻辑视图名解析成真正的视图（view） View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。 springmvc框架提供了很多的View视图类型，包括：jstlView、freemarkerView、pdfView等。 一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由工程师根据业务需求开发具体的页面。 6. 视图View(需要工程师开发jsp…) View是一个接口，实现类支持不同的View类型（jsp、freemarker、pdf…） 前端控制器（DispatcherServlet）：接收请求，响应结果，相当于电脑的CPU。 处理器映射器（HandlerMapping）：根据URL去查找处理器 处理器（Handler）：（需要程序员去写代码处理逻辑的） 处理器适配器（HandlerAdapter）：会把处理器包装成适配器，这样就可以支持多种类型的处理器，类比笔记本的适配器（适配器模式的应用） 视图解析器（ViewResovler）：进行视图解析，多返回的字符串，进行处理，可以解析成对应的页面","categories":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://example.com/categories/SpringMVC/"}],"tags":[{"name":"web框架","slug":"web框架","permalink":"http://example.com/tags/web%E6%A1%86%E6%9E%B6/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://example.com/tags/SpringMVC/"}]},{"title":"Manjaro安装.AppImage文件","slug":"2019-12-4-安装.AppImage文件","date":"2019-12-04T11:20:00.000Z","updated":"2020-05-26T07:13:35.000Z","comments":true,"path":"2019/12/04/2019-12-4-安装.AppImage文件/","link":"","permalink":"http://example.com/2019/12/04/2019-12-4-%E5%AE%89%E8%A3%85.AppImage%E6%96%87%E4%BB%B6/","excerpt":"","text":"把.AppImage 文件修改为可执行文件1chmod a+x *.AppImage 直接执行文件1./*.AppImage 也可以用界面直接双击运行。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"},{"name":"问题总结","slug":"问题总结","permalink":"http://example.com/categories/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"manjaro","slug":"manjaro","permalink":"http://example.com/tags/manjaro/"}]},{"title":"git hexo博客时出现:请告诉我你是谁。运行 git config --global提示","slug":"2019-12-4-git-hexo博客时出现请告诉我你是谁。运行-git-config---global提示","date":"2019-12-04T10:59:00.000Z","updated":"2019-12-04T11:38:21.000Z","comments":true,"path":"2019/12/04/2019-12-4-git-hexo博客时出现请告诉我你是谁。运行-git-config---global提示/","link":"","permalink":"http://example.com/2019/12/04/2019-12-4-git-hexo%E5%8D%9A%E5%AE%A2%E6%97%B6%E5%87%BA%E7%8E%B0%E8%AF%B7%E5%91%8A%E8%AF%89%E6%88%91%E4%BD%A0%E6%98%AF%E8%B0%81%E3%80%82%E8%BF%90%E8%A1%8C-git-config---global%E6%8F%90%E7%A4%BA/","excerpt":"","text":"当将hexo博客部署到云服务器时，如果是第一次使用，会出现这样的提示： 1234567891011121314151617181920hexo d INFO Deploying: git INFO Setting up Git deployment... 已初始化空的 Git 仓库于 /home/candy/文档/hexo_blog/.deploy_git/.git/ *** 请告诉我你是谁。 运行 git config --global user.email &quot;you@example.com&quot; git config --global user.name &quot;Your Name&quot; 来设置您账号的缺省身份标识。 如果仅在本仓库设置身份标识，则省略 --global 参数。 fatal: 无法自动探测邮件地址（得到 &#x27;candy@candy-pc.(none)&#x27;） FATAL Something&#x27;s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.html Error: Spawn failed at ChildProcess.&lt;anonymous&gt; (/home/candy/文档/hexo_blog/node_modules/hexo-util/lib/spawn.js:51:21) at ChildProcess.emit (events.js:210:5) at Process.ChildProcess._handle.onexit (internal/child_process.js:272:12) 按照提示输入就行： 12git config --global user.email &quot;在这里输入github帐号的邮箱&quot; git config --global user.name &quot;在这里输入github帐号的昵称&quot; 然后就好了。","categories":[{"name":"Blog","slug":"Blog","permalink":"http://example.com/categories/Blog/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}]},{"title":"在阿里云上搭建Hexo博客(一)","slug":"2019-11-22-在阿里云上搭建Hexo博客(一)","date":"2019-11-22T12:18:00.000Z","updated":"2020-05-18T13:41:03.000Z","comments":true,"path":"2019/11/22/2019-11-22-在阿里云上搭建Hexo博客(一)/","link":"","permalink":"http://example.com/2019/11/22/2019-11-22-%E5%9C%A8%E9%98%BF%E9%87%8C%E4%BA%91%E4%B8%8A%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2(%E4%B8%80)/","excerpt":"本文主要内容是初步搭建Hexo博客的主要过程。其中，本地操作系统是manjaro，云服务器是阿里云的centos。虽然网上有很多搭建Hexo博客的很多博文，但是有很多是基于github搭建的，很少有自建服务器的，当时搭建这个博客的时候参考了很多文章，所以自己现在提供一个完全可行的教程。","text":"本文主要内容是初步搭建Hexo博客的主要过程。其中，本地操作系统是manjaro，云服务器是阿里云的centos。虽然网上有很多搭建Hexo博客的很多博文，但是有很多是基于github搭建的，很少有自建服务器的，当时搭建这个博客的时候参考了很多文章，所以自己现在提供一个完全可行的教程。 准备工作首先要注册域名以及购买云服务器，这些流程都很简单，这里就不说了。 开启80端口新购买的阿里云系统是默认没有开启80端口的，而这是HTTP协议的端口号，如果不开启，直接使用域名是无法访问你的网站的。所以需要首先开启这个端口。 进入阿里云管理控制台，选择管理实例 点击本实例安全组，选择配置规则 点击右上角的添加安全组规则 。其中端口范围：80/80，授权对象：0.0.0.0/0 如下图为添加完80端口后的示意图： 配置服务器安装Ngnix安装执行命令如下： 1yum install -y ngnix 启动服务器： 12systemctl start ngnixsystemctl enable ngnix 配置服务器路由安装并启动服务器后，那么就可以使用公网IP访问我们的服务器了。此时指向的是一个默认地址，但是我们需要的是将IP指向我们的博客地址，那么就需要配置nginx的配置文件了。编辑配置文件/etc/nginx/nginx.conf： 1234567891011121314151617181920server &#123; listen 80 default_server; listen [::]:80 default_server; server_name www.candysky.top; //这里写服务器的域名 root /home/blog/websites; //这里是博客目录的存放位置 # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / &#123; &#125; error_page 404 /404.html; location = /40x.html &#123; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; &#125; &#125; 保存后退出。 安装Node.js12curl -sL https://rpm.nodesource.com/setup_10.x | bash -yum install -y nodejs 执行命令检查一下是否安装成功： 12[root@izuf6eja/]# node -vv13.0.1 客户端操作安装Node.js &amp; npm使用命令行安装： 12pacman -S nodejspanman -S npm 查看版本号判断是否安装成功： 1234[candy-pc root]# node -vv12.13.0[candy-pc root]# npm -v6.12.1 安装Hexoarch系linux安装 hexo很方便 1pacman -S hexo 由于使用npm直接下载会有很多人遇到卡顿的问题(国外服务器)，所以我们要做的第一步工作是将npm换成淘宝的服务器。 cmd输入下面的命令： 123npm config set registry https://registry.npm.taobao.org# 然后安装cnpmnpm install -g cnpm --registry=https://registry.npm.taobao.org 然后我们选一个目录用来初始化博客程序： 12cd Bloghexo init 执行成功后安装两个插件 12npm install hexo-deployer-git --savenpm install hexo-server 之后我们就可以在自己的本机上查看自己的博客了 12hexo ghexo s 打开浏览器访问 http://localhost:4000 配置_config.yml完成服务器的部署 在刚才生成hexo的目录下，找到_config.yml，打开它。 找到deploy 做如下配置 12345deploy:type: gitrepo: git@这里改为服务器公网IP:/home/git/blog.git branch: master message: 保存退出 然后尝试写一篇文章并且发布到服务器上 12hexo new &quot;Hello My First Blog&quot;hexo clean &amp;&amp; hexo generate --deploy 在服务器上重新运行nginx服务器 nginx -s relo 开启ssh服务对于manjaro系统而言，我们使用系统自带的ssh可以直接访问服务器。 如果没有开启ssh服务，首先需要开启： 1systemctl start sshd.service 让ssh服务开机自启： 1systemctl enable sshd.service 另外，系统自带git系统了，可以查看一下Git版本: 1pacman -Q git 配置_config.yml完成服务器的部署在刚才生成hexo的目录下，找到_config.yml，打开它。 找到deploy 做如下配置 12345deploy:type: gitrepo: git@这里改为服务器公网IP:/home/git/blog.git branch: master message: 保存退出 然后尝试写一篇文章并且发布到服务器上 12hexo new &quot;Hello My First Blog&quot;hexo clean &amp;&amp; hexo generate --deploy 在服务器上重新运行nginx服务器 nginx -s reload 完成部署完成部署后可以去Hexo主题下载自己喜欢的主题，美化博客了。","categories":[{"name":"Blog","slug":"Blog","permalink":"http://example.com/categories/Blog/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"},{"name":"阿里云","slug":"阿里云","permalink":"http://example.com/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"},{"name":"manjaro","slug":"manjaro","permalink":"http://example.com/tags/manjaro/"}]},{"title":"Hello World","slug":"2019-11-21-Hello-World","date":"2019-11-21T09:16:54.000Z","updated":"2019-11-21T15:28:17.000Z","comments":true,"path":"2019/11/21/2019-11-21-Hello-World/","link":"","permalink":"http://example.com/2019/11/21/2019-11-21-Hello-World/","excerpt":"写一写本博客主要的内容有什么～","text":"写一写本博客主要的内容有什么～ 前言这个文章就是为了留个纪念然后一些闲聊~ 写博客的初衷我写这个博客就是想把自己折腾过的东西都记一记，然后顺便把经验和其他东西分享给各位！ 我会往博客放的内容有 Java语言的各种心得、总结 搭建各种东西 如: 这个博客、各种开发环境等等 采坑经历分享 各种有趣的东西最后…希望大家多多评论，如有不足的地方各位可以提意见哦-v-","categories":[{"name":"杂文","slug":"杂文","permalink":"http://example.com/categories/%E6%9D%82%E6%96%87/"}],"tags":[{"name":"闲聊","slug":"闲聊","permalink":"http://example.com/tags/%E9%97%B2%E8%81%8A/"}]}],"categories":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/categories/Spring/"},{"name":"Web","slug":"Web","permalink":"http://example.com/categories/Web/"},{"name":"JDBC","slug":"JDBC","permalink":"http://example.com/categories/JDBC/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://example.com/categories/SpringMVC/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"},{"name":"问题总结","slug":"问题总结","permalink":"http://example.com/categories/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"},{"name":"Blog","slug":"Blog","permalink":"http://example.com/categories/Blog/"},{"name":"杂文","slug":"杂文","permalink":"http://example.com/categories/%E6%9D%82%E6%96%87/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/tags/Spring/"},{"name":"Jsp","slug":"Jsp","permalink":"http://example.com/tags/Jsp/"},{"name":"Web","slug":"Web","permalink":"http://example.com/tags/Web/"},{"name":"JDBC","slug":"JDBC","permalink":"http://example.com/tags/JDBC/"},{"name":"web框架","slug":"web框架","permalink":"http://example.com/tags/web%E6%A1%86%E6%9E%B6/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://example.com/tags/SpringMVC/"},{"name":"manjaro","slug":"manjaro","permalink":"http://example.com/tags/manjaro/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"},{"name":"阿里云","slug":"阿里云","permalink":"http://example.com/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"},{"name":"闲聊","slug":"闲聊","permalink":"http://example.com/tags/%E9%97%B2%E8%81%8A/"}]}